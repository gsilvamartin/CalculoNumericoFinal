
/**
 * A function that takes a vector of inputs and produces an output.  This must always
 * be a pure function that is linear in its coefficients.
 * @public
 */
export declare type ApproximationFunction<S> = (input: Vector<S>) => S;

/**
 * A higher-order function which is used to generate an `ApproximationFunction`.  This
 * must be linear in its coefficients, or the result of the linear regression will not
 * be correct.
 * @public
 */
export declare type ApproximationFunctionTemplate<S> = (coefficients: Vector<S>) => ApproximationFunction<S>;

/**
 * Implements {@link Matrix} with a 2-dimensional array of values.
 *
 * @remarks
 * Subclasses must specify the usual scalar operations on their contents.
 *
 * @public
 */
export declare abstract class ArrayMatrix<S = number> implements Matrix<S> {
    private readonly _data;
    /**
     * @internal
     */
    protected constructor(data: MatrixData<S>);
    /**
     * {@inheritdoc Matrix.ops}
     */
    abstract ops(): ScalarOperations<S>;
    /**
     * {@inheritdoc Matrix.builder}
     */
    abstract builder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    /**
     * {@inheritdoc Matrix.vectorBuilder}
     */
    abstract vectorBuilder(): VectorBuilder<S, Vector<S>>;
    /**
     * {@inheritDoc Matrix.add}
     */
    add(other: Matrix<S>): Matrix<S>;
    /**
     * {@inheritDoc Matrix.adjoint}
     */
    adjoint(): Matrix<S>;
    /**
     * {@inheritDoc Matrix.trace}
     */
    trace(): S;
    /**
     * {@inheritDoc Matrix.apply}
     */
    apply(vector: Vector<S>): Vector<S>;
    /**
     * {@inheritDoc Matrix.equals}
     */
    equals(other: Matrix<S>): boolean;
    /**
     * {@inheritDoc Matrix.getColumn}
     */
    getColumn(j: number): Vector<S>;
    /**
     * {@inheritDoc Matrix.getColumnVectors}
     */
    getColumnVectors(): Vector<S>[];
    /**
     * {@inheritDoc Matrix.getDiagonal}
     */
    getDiagonal(): Vector<S>;
    /**
     * {@inheritDoc Matrix.toArray}
     */
    toArray(): S[][];
    /**
     * {@inheritdoc Matrix.getSparseData}
     */
    getSparseData(): Map<number, Map<number, S>>;
    /**
     * {@inheritDoc Matrix.getEntry}
     */
    getEntry(i: number, j: number): S;
    /**
     * {@inheritDoc Matrix.getShape}
     */
    getShape(): MatrixShape;
    /**
     * {@inheritDoc Matrix.getNumberOfColumns}
     */
    getNumberOfColumns(): number;
    /**
     * {@inheritDoc Matrix.getNumberOfRows}
     */
    getNumberOfRows(): number;
    /**
     * {@inheritDoc Matrix.getRow}
     */
    getRow(i: number): Vector<S>;
    /**
     * {@inheritDoc Matrix.getRowVectors}
     */
    getRowVectors(): Vector<S>[];
    /**
     * {@inheritDoc Matrix.multiply}
     */
    multiply(other: Matrix<S>): Matrix<S>;
    /**
     * {@inheritDoc Matrix.scalarMultiply}
     */
    scalarMultiply(scalar: S): Matrix<S>;
    /**
     * {@inheritDoc Matrix.set}
     */
    set(i: number, j: number, value: S): Matrix<S>;
    /**
     * {@inheritDoc Matrix.transpose}
     */
    transpose(): Matrix<S>;
    /**
     * {@inheritDoc Matrix.forEach}
     */
    forEach(cb: (value: S, i: number, j: number) => void): void;
    /**
     * {@inheritDoc Matrix.map}
     */
    map(entryFunction: (entry: S, rowIndex: number, columnIndex: number) => S): Matrix<S>;
    /**
     * {@inheritDoc Matrix.combine}
     */
    combine(other: Matrix<S>, combineEntries: (a: S, b: S) => S): Matrix<S>;
}

/**
 * Implements {@link Vector} with an array of values.
 *
 * @remarks
 * Subclasses must specify the usual scalar operations on their contents.
 *
 * @public
 */
export declare abstract class ArrayVector<S = number> implements Vector<S> {
    private readonly _data;
    /**
     * @internal
     */
    protected constructor(data: VectorData<S>);
    /**
     * {@inheritdoc Vector.ops}
     */
    abstract ops(): ScalarOperations<S>;
    /**
     * {@inheritdoc Vector.builder}
     */
    abstract builder(): VectorBuilder<S, Vector<S>>;
    /**
     * {@inheritdoc Vector.matrixBuilder}
     */
    abstract matrixBuilder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    /**
     * {@inheritDoc Vector.getEntry}
     */
    getEntry(index: number): S;
    /**
     * {@inheritDoc Vector.set}
     */
    set(index: number, value: S): Vector<S>;
    /**
     * {@inheritDoc Vector.add}
     */
    add(other: Vector<S>): Vector<S>;
    /**
     * {@inheritDoc Vector.equals}
     */
    equals(other: Vector<S>): boolean;
    /**
     * {@inheritDoc Vector.innerProduct}
     */
    innerProduct(other: Vector<S>): S;
    /**
     * {@inheritDoc Vector.outerProduct}
     */
    outerProduct(other: Vector<S>): Matrix<S>;
    /**
     * {@inheritDoc Vector.projectOnto}
     */
    projectOnto(u: Vector<S>): Vector<S>;
    /**
     * {@inheritDoc Vector.scalarMultiply}
     */
    scalarMultiply(scalar: S): Vector<S>;
    /**
     * {@inheritDoc Vector.toArray}
     */
    toArray(): S[];
    /**
     * {@inheritDoc Vector.getSparseData}
     */
    getSparseData(): Map<number, S>;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    getDimension(): number;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    forEach(callback: (entry: S, index: number) => void): void;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    map(valueFromEntry: (entry: S, index: number) => S): Vector<S>;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    combine(other: Vector<S>, combineEntries: (entry1: S, entry2: S) => S): Vector<S>;
}

/**
 * Builds a matrix that transforms a vector to a vector of backward differences
 *
 * @remarks
 * A backward difference matrix calculates an approximate derivative scaled by the difference
 * when applied to a vector of function values, using a backward difference _f(x) - f(x - delta)_
 *
 * @example
 * ```
 * backwardDifferenceMatrix(4);
 *
 * // [  1  0  0  0 ]
 * // [ -1  1  0  0 ]
 * // [  0 -1  1  0 ]
 * // [  0  0 -1  1 ]
 * ```
 * @param binCount - The size of the vector to which the output ought to be applied
 * @returns The backward difference matrix
 * @public
 */
export declare function backwardDifferenceMatrix(binCount: number): NumberMatrix;

/**
 * Uses the serial version of the Cholesky algorith to calculate the Cholesky
 * decomposition of a matrix `A`.
 *
 * @remarks
 * A Cholesky decomposition of a matrix `A` consists of a lower-triangular
 * matrix `L` such that _LL* = A_.
 *
 * A Cholesky decomposition only exists if `A` is symmetric and positive-definite.
 * @param A - The matrix to decompose
 * @public
 */
export declare function calculateCholeskyDecomposition<S>(A: Matrix<S>): CholeskyDecomposition<S> | undefined;

/**
 * Uses the QR algorithm to compute the eigenvalues of a matrix `A`
 *
 * @param A - The matrix for which to compute eigenvalues
 * @param numIterations - The number of iterations to take
 * @public
 */
export declare function calculateEigenvalues<S>(A: Matrix<S>, numIterations?: number): Vector<S>;

/**
 * Calculates a regression model for an arbitrary function.
 *
 * @remarks
 * The result is on object which has:
 * - `coefficients`: a vector whose entries correspond to the coefficients which must
 *     be plugged into the function template to yield the best approximation function
 * - `approximationFunction`: a function which takes a vector of the independent variable
 *     values, and returns the predicted value of the dependent variable
 *
 * @param dataPoints - The data used to construct the approximation
 * @param functionTemplate - A higher-order
 *     function which takes a vector of coefficients and yields a new function which takes
 *     a vector of independent variables to produce a value for the dependent variable
 * @param numberOfTerms - The number of coefficients needed to produce
 *     the approximation function
 * @returns - the result of the linear regression
 * @public
 */
export declare function calculateGeneralLeastSquares<S>(dataPoints: Vector<S>[], functionTemplate: ApproximationFunctionTemplate<S>, numberOfTerms: number): LeastSquaresApproximation<S>;

/**
 * Calculates a linear regression model for the provided `dataPoints`.
 *
 * @remarks
 * The result is an object which has:
 * - `coefficients`: a vector whose first entry is the constant term, and whose
 *     following entries are the coefficients for the other independent variables, in
 *     the same order they appear in the `dataPoints`
 * - `approximationFunction`: a function which takes a vector of the independent variable
 *     values, and returns the predicted value of the dependent variable
 *
 * @param dataPoints - An array of vectors, each of which
 *    represents a single data point where the last entry is the variable to be predicted,
 *    and the other entries are the values of the independent variables
 * @returns - the result of the linear regression
 * @public
 */
export declare function calculateLinearLeastSquares<S>(dataPoints: Vector<S>[]): LeastSquaresApproximation<S>;

/**
 * Uses the Doolittle algorithm to calculate the LU Decomposition of a matrix A.
 *
 * @remarks
 * An LU Decomposition of a matrix A is a lower-triangular matrix L, an upper-triangular
 * matrix U, and a row permutation matrix P such that _PA = LU_
 *
 * @param A - The matrix to decompose
 * @public
 */
export declare function calculateLUDecomposition<S>(A: Matrix<S>): LUDecomposition<S>;

/**
 * Uses the Graham-Schmidt process to calculate the QR decomposition of the matrix A.
 *
 * @remarks
 * A QR Decomposition of a matrix A is a unitary matrix Q and upper-triangular
 * matrix R such that Q multiplied by R yields A
 *
 * @param A - The matrix to decompose
 * @public
 */
export declare function calculateQRDecomposition<S>(A: Matrix<S>): QRDecomposition<S>;

/**
 * Uses the Power Method to calculate the Singular Value Decomposition of a matrix `A`
 *
 * @remarks
 * A Singular Value Decomposition consists of orthogonal matrices `U` and `V`
 * and a diagonal matrix `Sigma` such that _USigmaV* = A_
 *
 * @param A - the matrix to decompose
 * @public
 */
export declare function calculateSingularValueDecomposition<S>(A: Matrix<S>): SingularValueDecomposition<S>;

/**
 * Returns the vector `x`, shifted so that its mean is at 0
 * @param x - The vector to center
 * @public
 */
export declare function center<S>(x: Vector<S>): Vector<S>;

/**
 * Returns the matrix `A` with each column shifted so that its mean is at 0
 * @remarks
 * This does not shift the entire matrix uniformly
 * @param A - The matrix to center
 * @public
 */
export declare function center<S>(A: Matrix<S>): Matrix<S>;

/**
 * Builds a matrix that transforms a vector to a vector of central differences
 *
 * @remarks
 * A backward difference matrix calculates an approximate derivative scaled by the difference
 * when applied to a vector of function values, using a central
 * difference _f(x - delta)/2 - f(x + delta)/2_
 *
 * The central difference is equal to the average of the forward and backward differences
 * _1/2 * (forwardDifference + backwardDifference)_
 *
 * @example
 * ```
 * centralDifferenceMatrix(4);
 *
 * // [   0   1/2   0    0  ]
 * // [ -1/2   0   1/2   0  ]
 * // [   0  -1/2   0   1/2 ]
 * // [   0    0  -1/2   0  ]
 * ```
 * @param binCount - The size of the vector to which the output ought to be applied
 * @returns The central difference matrix
 * @public
 */
export declare function centralDifferenceMatrix(binCount: number): NumberMatrix;

/**
 * The result of a Cholesky Decomposition
 * @public
 */
export declare interface CholeskyDecomposition<S> {
    L: Matrix<S>;
}

/**
 * A machine learning model with a continuous numeric target
 * @public
 */
export declare interface Classifier<H> {
    /**
     * Learns the optimal set of parameters for the model.
     *
     * @param data - A {@link Matrix} whose rows are the individual observations in the training set
     * @param target - A {@link Vector} whose entries are the target values in the training set
     * @public
     */
    train(data: Matrix, target: Vector): void;
    /**
     * Uses the learned parameters to make predictions for the probability of an event
     * based on a set of input data.
     *
     * @remarks
     * Must be called after {@link Classifier.train}
     *
     * @param data - A {@link Vector} whose rows are the observations in the test set
     * @public
     */
    predictProbabilities(data: Matrix): Vector;
    /**
     * Uses the learned parameters to make predictions based on a set of input data.
     *
     * @remarks
     * Must be called after {@link Classifier.train}
     *
     * @param data - A {@link Vector} whose rows are the observations in the test set
     * @param pThreshold - The probability threshold above which an event will be predicted
     * @public
     */
    predict(data: Matrix, pThreshold: number): Vector;
    /**
     * Return the full set of hyperparameters used to train the model, including defaults.
     * @public
     */
    getHyperParameters(): H;
}

/**
 * Calculates the 1-Norm of a matrix `A`
 *
 * @example
 * ```
 * const A = mat([[1, 2], [3, 4]]);
 * const norm = columnSumSupremumNorm(A); // 6
 * ```
 *
 * @param A - The matrix for which to calculate the norm
 * @public
 */
export declare function columnSumSupremumNorm<S>(A: Matrix<S>): number;

/**
 * A dense {@link Matrix} of {@link ComplexNumber}s, implemented as an {@link ArrayMatrix}
 * @public
 */
export declare class ComplexMatrix extends ArrayMatrix<ComplexNumber> {
    static ops(): ScalarOperations<ComplexNumber>;
    static builder(): MatrixBuilder<ComplexNumber, ComplexVector, ComplexMatrix>;
    static vectorBuilder(): VectorBuilder<ComplexNumber, ComplexVector>;
    /**
     * @internal
     */
    constructor(data: MatrixData<ComplexNumber>);
    /**
     * {@inheritDoc ArrayMatrix.ops}
     */
    ops(): ScalarOperations<ComplexNumber>;
    /**
     * {@inheritDoc ArrayMatrix.builder}
     */
    builder(): MatrixBuilder<ComplexNumber, ComplexVector, ComplexMatrix>;
    /**
     * {@inheritDoc ArrayMatrix.vectorBuilder}
     */
    vectorBuilder(): VectorBuilder<ComplexNumber, ComplexVector>;
}

/**
 * A number of the form _a + bi_ where _i_ is the imaginary unit.
 * @public
 */
export declare class ComplexNumber {
    static readonly ZERO: ComplexNumber;
    static readonly ONE: ComplexNumber;
    static readonly NEG_ONE: ComplexNumber;
    static readonly I: ComplexNumber;
    private readonly _real;
    private readonly _imaginary;
    constructor(real: number, imaginary: number);
    getRealPart(): number;
    getImaginaryPart(): number;
    add(other: ComplexNumber): ComplexNumber;
    multiply(other: ComplexNumber): ComplexNumber;
    getAdditiveInverse(): ComplexNumber;
    getMultiplicativeInverse(): ComplexNumber | undefined;
    equals(other: ComplexNumber): boolean;
    conjugate(): ComplexNumber;
}

/**
 * Implements the basic {@link ScalarOperations} on {@link ComplexNumber}s
 * @public
 */
export declare class ComplexNumberOperations extends ScalarOperations<ComplexNumber> {
    /**
     * {@inheritdoc ScalarOperations.fromNumber}
     */
    fromNumber(num: number): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.fromComplex}
     */
    fromComplex(real: number, imag: number): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.conjugate}
     */
    conjugate(scalar: ComplexNumber): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.getAdditiveIdentity}
     */
    getAdditiveIdentity(): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.getAdditiveInverse}
     */
    getAdditiveInverse(scalar: ComplexNumber): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.getMultiplicativeIdentity}
     */
    getMultiplicativeIdentity(): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.getMultiplicativeInverse}
     */
    getMultiplicativeInverse(scalar: ComplexNumber): ComplexNumber | undefined;
    /**
     * {@inheritdoc ScalarOperations.multiply}
     */
    multiply(first: ComplexNumber, second: ComplexNumber): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.getPrincipalSquareRoot}
     */
    getPrincipalSquareRoot(x: ComplexNumber): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.norm}
     */
    norm(x: ComplexNumber): number;
    /**
     * {@inheritdoc ScalarOperations.equals}
     */
    equals(first: ComplexNumber, second: ComplexNumber): boolean;
    /**
     * {@inheritdoc ScalarOperations.add}
     */
    add(first: ComplexNumber, second: ComplexNumber): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.random}
     */
    random(min?: number, max?: number): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.randomNormal}
     */
    randomNormal(mean?: number, standardDeviation?: number): ComplexNumber;
    /**
     * {@inheritdoc ScalarOperations.prettyPrint}
     */
    prettyPrint(x: ComplexNumber): string;
}

/**
 * A dense {@link Vector} of {@link ComplexNumber}s implemented as an {@link ArrayVector}
 * @public
 */
export declare class ComplexVector extends ArrayVector<ComplexNumber> {
    static ops(): ComplexNumberOperations;
    static builder(): VectorBuilder<ComplexNumber, ComplexVector>;
    /**
     * @internal
     */
    constructor(data: VectorData<ComplexNumber>);
    /**
     * {@inheritDoc ArrayVector.ops}
     */
    ops(): ComplexNumberOperations;
    /**
     * {@inheritDoc ArrayVector.builder}
     */
    builder(): VectorBuilder<ComplexNumber, ComplexVector>;
    /**
     * {@inheritDoc ArrayVector.matrixBuilder}
     */
    matrixBuilder(): MatrixBuilder<ComplexNumber, ComplexVector, ComplexMatrix>;
}

/**
 * Calculates the correlation coefficient r of two vectors
 * @param first - The first vector
 * @param second - The second vector
 * @public
 */
export declare function correlation<S>(first: Vector<S>, second: Vector<S>): S;

/**
 * Calculates the correlation matrix of a matrix `A`
 * @param A - The matrix
 * @public
 */
export declare function correlation<S>(A: Matrix<S>): Matrix<S>;

/**
 * The output of a cost function
 * @public
 */
export declare interface Cost {
    cost: number;
    gradient: Vector;
}

/**
 * A function that evaluates the cost of a set of parameters `theta`
 * @public
 */
export declare type CostFunction = (theta: Vector) => Cost;

/**
 * Calculates the covariance of two vectors
 * @param first - The first vector
 * @param second - The second vector
 * @public
 */
export declare function covariance<S>(first: Vector<S>, second: Vector<S>): S;

/**
 * Calculates the covariance matrix of a matrix `A`
 * @param A - The matrix
 * @public
 */
export declare function covariance<S>(A: Matrix<S>): Matrix<S>;

/**
 * Calculates the cross-product (vector-product) of two vectors.
 * This is defined only for vectors with three dimensions.
 *
 * @param first - a vector with dimension 3
 * @param second - another vector with dimension 3
 *
 * @public
 */
export declare function crossProduct<S>(first: Vector<S>, second: Vector<S>): Vector<S>;

/**
 * Uses finite differences to build a vector containing approximate values of the derivative of `f`.
 *
 * @example
 * ```
 * // Approximates Math.cos at 100 points between 0 and 2*PI
 * derivative(Math.sin, 0, 2*Math.PI, 100);
 * ```
 *
 * @param f - A deterministic function with no side effects
 * @param xMin - The minimum value for which the derivative will be approximated
 * @param xMax - The maximum (exclusive) value for which the derivative will be approximated
 * @param binCount - The number of approximations
 * @returns A linearly spaced vector whose values represent the values of the derivative
 * @public
 */
export declare function derivative(f: (x: number) => number, xMin: number, xMax: number, binCount: number): Vector;

/**
 * Uses expansion of minors to calculate the determinant of a matrix.
 * Throws an error if the input is not square.
 *
 * @param matrix - A square matrix
 * @returns - The determinant
 * @public
 */
export declare function determinant<S>(matrix: Matrix<S>): S;

/**
 * Creates a new matrix with the specified entries on the diagonal.  See {@link MatrixBuilder.diagonal}
 * @public
 */
export declare function diag(elements: number[]): Matrix;

/**
 * Specify how dimension reduction ought to be done.
 * @public
 */
export declare type DimensionReductionOptions = DimensionReductionType & {
    useCorrelation?: boolean;
};

declare type DimensionReductionType = {
    keep: number;
} | {
    remove: number;
} | {
    proportionOfVariance: number;
};

/**
 * Computes the dot/inner/scalar product of two vectors.  See {@link Vector.innerProduct}.
 *
 * @param first - the left vector in the product
 * @param second - the right vector in the product
 *
 * @public
 */
export declare function dotProduct<S>(first: Vector<S>, second: Vector<S>): S;

/**
 * Uses the QR algorithm to compute the eigenvalues and eigenvectors of a matrix `A`
 *
 * @param A - The matrix for which to compute eigenvalues
 * @param numIterations - The number of iterations to take
 * @returns An array of eigenvalue-eigenvalue pairs
 * @public
 */
export declare function eig<S>(A: Matrix<S>, numIterations?: number): EigenPair<S>[];

/**
 * An eigenvector and its corresponding eigenvalue
 * @public
 */
export declare interface EigenPair<S> {
    eigenvalue: S;
    eigenvector: Vector<S>;
}

/**
 * Calculates the Euclidean Norm (or 2-Norm) of a vector `v`
 *
 * @example
 * ```
 * const v = vec([3, 4]);
 * const norm = euclideanNorm(v); // 5
 * ```
 *
 * @param v - The vector for which to calculate the norm
 * @public
 */
export declare function euclideanNorm<S>(v: Vector<S>): number;

/**
 * Implements the Pade Approximant to compute the exponential of matrix `A`
 *
 * @param A - The matrix to exponentiate
 * @param order - The order of the approximation - higher numbers yield more accurate results
 * @public
 */
export declare function exp<S>(A: Matrix<S>, order?: number): Matrix<S>;

/**
 * Creates a new identity matrix of size `size`.  See {@link MatrixBuilder.identity}
 * @public
 */
export declare function eye(size: number): Matrix;

/**
 * A dense matrix of JavaScript `number` primitives, implemented as a column-major `Float64Array`
 * @public
 */
export declare class FloatMatrix implements Matrix<number> {
    static ops(): ScalarOperations<number>;
    static builder(): MatrixBuilder<number, FloatVector, FloatMatrix>;
    static vectorBuilder(): VectorBuilder<number, FloatVector>;
    private _data;
    private _shape;
    /**
     * @internal
     */
    constructor(data: MatrixData<number>);
    constructor(data: Float64Array, shape: MatrixShape);
    /**
     * {@inheritDoc ArrayMatrix.ops}
     */
    ops(): ScalarOperations<number>;
    /**
     * {@inheritDoc ArrayMatrix.builder}
     */
    builder(): MatrixBuilder<number, FloatVector, FloatMatrix>;
    /**
     * {@inheritDoc ArrayMatrix.vectorBuilder}
     */
    vectorBuilder(): VectorBuilder<number, FloatVector>;
    /**
     * {@inheritDoc Matrix.add}
     */
    add(other: Matrix<number>): Matrix<number>;
    /**
     * {@inheritDoc Matrix.adjoint}
     */
    adjoint(): Matrix<number>;
    /**
     * {@inheritDoc Matrix.trace}
     */
    trace(): number;
    /**
     * {@inheritDoc Matrix.apply}
     */
    apply(vector: Vector<number>): Vector<number>;
    /**
     * {@inheritDoc Matrix.equals}
     */
    equals(other: Matrix<number>): boolean;
    /**
     * {@inheritDoc Matrix.getColumn}
     */
    getColumn(j: number): Vector<number>;
    /**
     * {@inheritDoc Matrix.getColumnVectors}
     */
    getColumnVectors(): Vector<number>[];
    /**
     * {@inheritDoc Matrix.getDiagonal}
     */
    getDiagonal(): Vector<number>;
    /**
     * {@inheritDoc Matrix.toArray}
     */
    toArray(): number[][];
    /**
     * {@inheritdoc Matrix.getSparseData}
     */
    getSparseData(): Map<number, Map<number, number>>;
    /**
     * {@inheritDoc Matrix.getEntry}
     */
    getEntry(i: number, j: number): number;
    /**
     * {@inheritDoc Matrix.getShape}
     */
    getShape(): MatrixShape;
    /**
     * {@inheritDoc Matrix.getNumberOfColumns}
     */
    getNumberOfColumns(): number;
    /**
     * {@inheritDoc Matrix.getNumberOfRows}
     */
    getNumberOfRows(): number;
    /**
     * {@inheritDoc Matrix.getRow}
     */
    getRow(i: number): Vector<number>;
    /**
     * {@inheritDoc Matrix.getRowVectors}
     */
    getRowVectors(): Vector<number>[];
    /**
     * {@inheritDoc Matrix.multiply}
     */
    multiply(other: Matrix<number>): Matrix<number>;
    /**
     * {@inheritDoc Matrix.scalarMultiply}
     */
    scalarMultiply(scalar: number): Matrix<number>;
    /**
     * {@inheritDoc Matrix.set}
     */
    set(i: number, j: number, value: number): Matrix<number>;
    /**
     * {@inheritDoc Matrix.transpose}
     */
    transpose(): Matrix<number>;
    /**
     * {@inheritDoc Matrix.forEach}
     */
    forEach(cb: (entry: number, rowIndex: number, columnIndex: number) => void): void;
    /**
     * {@inheritDoc Matrix.map}
     */
    map(entryFunction: (entry: number, rowIndex: number, columnIndex: number) => number): Matrix<number>;
    /**
     * {@inheritDoc Matrix.combine}
     */
    combine(other: Matrix<number>, combineEntries: (a: number, b: number) => number): Matrix<number>;
    private getArrayIndex;
    private getIndices;
}

/**
 * A dense {@link Vector} of `number`s implemented as a `Float64Array`
 * @public
 */
export declare class FloatVector implements Vector<number> {
    static ops(): NumberOperations;
    static builder(): VectorBuilder<number, FloatVector>;
    private _data;
    /**
     * @internal
     */
    constructor(data: VectorData<number> | Float64Array);
    /**
     * {@inheritDoc ArrayVector.ops}
     */
    ops(): NumberOperations;
    /**
     * {@inheritDoc ArrayVector.builder}
     */
    builder(): VectorBuilder<number, FloatVector>;
    /**
     * {@inheritDoc ArrayVector.matrixBuilder}
     */
    matrixBuilder(): MatrixBuilder<number, FloatVector, FloatMatrix>;
    /**
     * {@inheritDoc Vector.getEntry}
     */
    getEntry(index: number): number;
    /**
     * {@inheritDoc Vector.set}
     */
    set(index: number, value: number): Vector<number>;
    /**
     * {@inheritDoc Vector.add}
     */
    add(other: Vector<number>): Vector<number>;
    /**
     * {@inheritDoc Vector.equals}
     */
    equals(other: Vector<number>): boolean;
    /**
     * {@inheritDoc Vector.innerProduct}
     */
    innerProduct(other: Vector<number>): number;
    /**
     * {@inheritDoc Vector.outerProduct}
     */
    outerProduct(other: Vector<number>): Matrix<number>;
    /**
     * {@inheritDoc Vector.projectOnto}
     */
    projectOnto(u: Vector<number>): Vector<number>;
    /**
     * {@inheritDoc Vector.scalarMultiply}
     */
    scalarMultiply(scalar: number): Vector<number>;
    /**
     * {@inheritDoc Vector.toArray}
     */
    toArray(): number[];
    /**
     * {@inheritDoc Vector.getSparseData}
     */
    getSparseData(): Map<number, number>;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    getDimension(): number;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    forEach(callback: (entry: number, index: number) => void): void;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    map(valueFromEntry: (entry: number, index: number) => number): Vector<number>;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    combine(other: Vector<number>, combineEntries: (a: number, b: number) => number): Vector<number>;
}

/**
 * Builds a matrix that transforms a vector to a vector of forward differences
 *
 * @remarks
 * A forward difference matrix calculates an approximate derivative scaled by the difference
 * when applied to a vector of function values, using a forward difference _f(x + delta) - f(x)_
 *
 * @example
 * ```
 * forwardDifferenceMatrix(4);
 *
 * // [ -1  1  0  0 ]
 * // [  0 -1  1  0 ]
 * // [  0  0 -1  1 ]
 * // [  0  0  0 -1 ]
 * ```
 * @param binCount - The size of the vector to which the output ought to be applied
 * @returns The forward difference matrix
 * @public
 */
export declare function forwardDifferenceMatrix(binCount: number): NumberMatrix;

/**
 * Calculates the Frobenius Norm of a matrix `A`
 *
 * @example
 * ```
 * const A = mat([[1, 2], [3, 4]]);
 * const norm = frobeniusNorm(A); // sqrt(30)
 * ```
 *
 * @param A - The matrix for which to calculate the norm
 * @public
 */
export declare function frobeniusNorm<S>(A: Matrix<S>): number;

/**
 * Creates a gaussian {@link Kernel} for use in a {@link SupportVectorMachineClassifier}.
 * The gaussian kernel converts a data {@link Matrix} into a similarity `Matrix`
 * where the value of entry (i,j) expresses the similarity of rows i and j in
 * the original data set.
 *
 * @param sigmaSquared - The variance of the gaussian distribution used in the kernel
 *
 * @public
 */
export declare function GaussianKernel(sigmaSquared: number): Kernel;

/**
 * Given a matrix `A` and an eigenvalue `lambda` of that matrix, returns the
 * eigenvector of `A` corresponding to `lambda`
 *
 * @param A - The matrix with eigenvalue `lambda`
 * @param lambda - The eigenvalue for which to find an eigenvector
 * @public
 */
export declare function getEigenvectorForEigenvalue<S>(A: Matrix<S>, lambda: S): Vector<S>;

/**
 * Learns an optimal set of parameters `theta` using gradient descent
 *
 * @param parameters - The {@link GradientDescentParameters} which determine how the learning will run
 *
 * @public
 */
export declare function gradientDescent(parameters: Partial<GradientDescentParameters>): LearningAlgorithm;

/**
 * The parameters for {@link gradientDescent}
 * @public
 */
export declare type GradientDescentParameters = {
    alpha: number;
    maxIterations?: number;
};

/**
 * Computes the hadamard (element-wise) product of two vectors.
 *
 * @param first - the left vector in the product
 * @param second - the right vector in the product
 *
 * @public
 */
export declare function hadamardProduct<S>(first: Vector<S>, second: Vector<S>): Vector<S>;

/**
 * Computes the hadamard (element-wise) product of two matrices.
 *
 * @param first - the left matrix in the product
 * @param second - the right matrix in the product
 *
 * @public
 */
export declare function hadamardProduct<S>(first: Matrix<S>, second: Matrix<S>): Matrix<S>;

/**
 * Uses Gauss-Jordan elimination with pivoting to calculate the inverse of a matrix.
 *
 * @remarks
 * Throws an error if the matrix is not square.
 * Returns `undefined` if the matrix is not invertible.
 *
 * @param matrix - A square matrix
 * @returns The inverse matrix
 * @public
 */
export declare function inverse<S>(matrix: Matrix<S>): Matrix<S> | undefined;

/**
 * Tests if a matrix is Hermitian.
 *
 * @remarks
 * A matrix A is Hermitian if it is equal to its conjugate transpose
 *
 * @returns `true` if the matrix is Hermitian
 * @public
 */
export declare function isHermitian<S>(matrix: Matrix<S>): boolean;

/**
 * Tests if a matrix is an identity matrix
 *
 * @returns `true` if the matrix is an identity
 * @public
 */
export declare function isIdentity<S>(matrix: Matrix<S>): boolean;

/**
 * Tests if a matrix is lower-triangular.
 *
 * @remarks
 * A matrix is lower-triangular if all entries above the primary diagonal
 * (those where `i < j`) are zero.
 *
 * @returns `true` if the matrix is lower-triangular
 * @public
 */
export declare function isLowerTriangular<S>(matrix: Matrix<S>): boolean;

/**
 * Tests if a matrix is orthogonal
 *
 * @remarks
 * A matrix is orthogonal if each column is orthogonal to each other column.
 * That is, if for each pair of columns, their inner product is 0.
 *
 * @returns `true` if the matrix is orthogonal.
 * @public
 */
export declare function isOrthogonal<S>(matrix: Matrix<S>): boolean;

/**
 * Tests if a matrix is orthonormal
 *
 * @remarks
 * A matrix is orthonormal if is {@link isOrthogonal | orthogonal} and
 * if its columns all have norm 1.
 * An orthonormal matrix multiplied by its transpose is an identity.
 *
 * @returns `true` if the matrix is orthonormal
 * @public
 */
export declare function isOrthonormal<S>(matrix: Matrix<S>): boolean;

/**
 * A type guard which returns true if the input is an instance of `SparseVector`,
 * and functions as a type check in the compiler.
 *
 * @internal
 */
export declare function isSparse<S>(vector: Vector<S>): vector is SparseVector<S>;

/**
 * Tests if a matrix is square.
 *
 * @remarks
 * A matrix is square if it has the same number of rows as columns.
 *
 * @param matrix - The matrix to check
 * @returns `true` if `matrix` is square
 * @public
 */
export declare function isSquare(matrix: Matrix<any>): boolean;

/**
 * Tests if a matrix is symmetric.
 *
 * @remarks
 * A matrix A is symmetric if it is square and if A[i,j] = A[j,i] for all i and j
 *
 * @returns `true` if the matrix is symmetric
 * @public
 */
export declare function isSymmetric<S>(matrix: Matrix<S>): boolean;

/**
 * Tests if a matrix is upper-triangular.
 *
 * @remarks
 * A matrix is upper-triangular if all entries below the primary diagonal
 * (those where `i > j`) are zero.
 *
 * @returns `true` if the matrix is upper-triangular
 * @public
 */
export declare function isUpperTriangular<S>(matrix: Matrix<S>): boolean;

/**
 * A function which takes a {@link Matrix} of data
 * (and optionally another `Matrix` of data on which the kernel was trained)
 * and returns a new `Matrix` which will be used to train a machine learning model.
 *
 * Generally intended for use with a {@link SupportVectorMachineClassifier}.
 *
 * @public
 */
export declare type Kernel = (data: Matrix, trainingData?: Matrix) => Matrix;

/**
 * Computes the Kronecker product (generalized outer product) of two matrices.
 *
 * @param first - the left matrix in the product
 * @param second - the right matrix in the product
 *
 * @public
 */
export declare function kroneckerProduct<S>(first: Matrix<S>, second: Matrix<S>): Matrix<S>;

/**
 * An function which, given an initial value of `theta` and a CostFunction,
 * will compute the optimal value of `theta`
 * @public
 */
export declare type LearningAlgorithm = (initialTheta: Vector, costFn: CostFunction) => Vector;

/**
 * The result of a least squares approximation.
 * @public
 */
export declare interface LeastSquaresApproximation<S> {
    /**
     * A vector whose entries correspond to the coefficients which must
     * be plugged into the function template to yield the best approximation function
     */
    coefficients: Vector<S>;
    /**
     * A function which takes a vector of the independent variable
     * values, and returns the predicted value of the dependent variable
     */
    approximationFunction: ApproximationFunction<S>;
}

/**
 * A linear kernel for use in a {@link SupportVectorMachineClassifier}.
 * The linear kernel converts a data {@link Matrix} into a matrix which
 * has been prepended with a column of all ones, representing the constant
 * term in a linear model, or the bias term in an SVM.
 *
 * @param data - The variance of the gaussian distribution used in the kernel
 *
 * @public
 */
export declare function LinearKernel(data: Matrix): Matrix;

/**
 * A {@link Regressor} model which uses an ordinary least squares model with regularization to
 * predict a continuous target.
 * The optimal set of parameters is computed with gradient descent.
 * @public
 */
export declare class LinearRegressor implements Regressor<LinearRegressorHyperparams> {
    private readonly _hyperParameters;
    private _theta;
    constructor(hyperParameters: Partial<LinearRegressorHyperparams>);
    /**
     * Get the coefficients of the trained linear regression model, or
     * `undefined` if the model has not been trained.
     * @public
     */
    getParameters(): Vector | undefined;
    /**
     * {@inheritDoc Regressor.getHyperParameters}
     */
    getHyperParameters(): LinearRegressorHyperparams;
    /**
     * {@inheritDoc Regressor.train}
     */
    train(data: Matrix, target: Vector): void;
    /**
     * {@inheritDoc Regressor.predict}
     */
    predict(data: Matrix): Vector;
    private calculateCost;
    private calculateGradient;
    private makePredictions;
    private getDefaultHyperParameters;
}

/**
 * The set of hyperparameters for a {@link LinearRegressor}
 * @public
 */
export declare type LinearRegressorHyperparams = GradientDescentParameters & {
    /**
     * A number whose value influences the penalty for large coefficients.
     * Large values of `lambda` correspond to highly regularized models,
     * and correct for overfitting.
     * Small values of `lambda` correspond to highly biased models,
     * and correct for underfitting.
     */
    lambda: number;
};

declare type LinearSolution<S> = UniqueSolution<S> | OverdeterminedSolution | UnderdeterminedSolution<S>;

/**
 * An abstract linear transformation between vectors of type `V`
 * and vectors of type `U`.
 *
 * @remarks
 * Implementors should take care to ensure that the transformation is linear.
 * That is,
 *
 * _T(x + y) = T(x) + T(y)_
 *
 * _T(k * x) = k * T(x)_
 *
 * @public
 */
export declare interface LinearTransformation<V, U> {
    /**
     * Apply the linear transformation to a vector
     * @param vector - A vector in the domain of the transformation
     * @returns A vector in the image of the transformation
     * @public
     */
    apply(vector: V): U;
}

/**
 * Builds a vector of `binCount` evenly spaced numbers between `xMin` (inclusive) and `xMax` (exclusive).
 *
 * @remarks
 * Throws an error if `xMin` is greater than or equal to `xMax` or if `binCount` is negative
 *
 * @example
 * ```
 * linspace(0, 1, 5); // [ 0, 0.2, 0.4, 0.6, 0.8 ]
 * ```
 *
 * @param xMin - The smallest value in the vector
 * @param xMax - The largest value in the vector
 * @param binCount - The number of entries
 * @returns The evenly-spaced vector
 * @public
 */
export declare function linspace(xMin: number, xMax: number, binCount: number): NumberVector;

/**
 * A {@link Classifier} model which uses logistic regression to predict a discrete target.
 * The optimal set of parameters is computed with gradient descent.
 * @public
 */
export declare class LogisticRegressionClassifier implements Classifier<LogisticRegressionHyperparams> {
    private readonly _hyperParameters;
    private _theta;
    constructor(hyperParameters: Partial<LogisticRegressionHyperparams>);
    /**
     * Get the coefficients of the trained linear regression model, or
     * `undefined` if the model has not been trained.
     * @public
     */
    getParameters(): Vector | undefined;
    /**
     * {@inheritDoc Classifier.getHyperParameters}
     */
    getHyperParameters(): LogisticRegressionHyperparams;
    /**
     * {@inheritDoc Classifier.train}
     */
    train(data: Matrix, target: Vector): void;
    /**
     * {@inheritDoc Classifier.predictProbabilities}
     */
    predictProbabilities(data: Matrix): Vector;
    /**
     * {@inheritDoc Classifier.predict}
     */
    predict(data: Matrix): Vector;
    private makePredictions;
    private makeProbabilityPredictions;
    private calculateCost;
    /**
     * {@inheritDoc GradientDescentClassifier.calculateGradient}
     */
    private calculateGradient;
    private getDefaultHyperParameters;
}

/**
 * The set of hyperparameters for a {@link LogisticRegressionClassifier}
 * @public
 */
export declare type LogisticRegressionHyperparams = GradientDescentParameters & {
    /**
     * A number whose value influences the penalty for large coefficients.
     * Large values of `lambda` correspond to highly regularized models,
     * and correct for overfitting.
     * Small values of `lambda` correspond to highly biased models,
     * and correct for underfitting.
     */
    lambda: number;
};

/**
 * The result of an LU Decomposition
 * @public
 */
export declare interface LUDecomposition<S> {
    L: Matrix<S>;
    U: Matrix<S>;
    P: Matrix<S>;
}

/**
 * Creates a new {@link Matrix} of numbers.  See {@link MatrixBuilder.fromArray}
 * @public
 */
export declare function mat(data: number[][]): Matrix;

/**
 * A generalized Matrix - one of the core data types
 * @public
 */
export declare interface Matrix<S = number> extends LinearTransformation<Vector<S>, Vector<S>> {
    /**
     * Returns a {@link ScalarOperations} object which will allow consumers to work generically
     * with the scalars contained in the vector.
     * @public
     */
    ops(): ScalarOperations<S>;
    /**
     * Returns a {@link MatrixBuilder} which will build new matrices of the same type
     * @public
     */
    builder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    /**
     * Returns a {@link VectorBuilder} which will build new vectors of a compatible type
     * @public
     */
    vectorBuilder(): VectorBuilder<S, Vector<S>>;
    /**
     * Returns the contents of the matrix as a 2-D array.
     * @returns The contents of the matrix
     * @public
     */
    toArray(): S[][];
    /**
     * Returns the contents of the matrix as a nested map of rowIndex to columnIndex to nonzero value
     * @returns The contents of the matrix
     * @public
     */
    getSparseData(): Map<number, Map<number, S>>;
    /**
     * Returns a tuple representing the dimensions of the matrix.
     * The first entry is the number of rows, and the second entry is the number of columns.
     * @returns The shape of the matrix as a tuple
     * @public
     */
    getShape(): MatrixShape;
    /**
     * Returns the number of rows in the matrix
     * @returns The number of rows
     * @public
     */
    getNumberOfRows(): number;
    /**
     * Returns the number of columns in the matrix
     * @returns The number of columns
     * @public
     */
    getNumberOfColumns(): number;
    /**
     * Returns an array of vectors corresponding to the rows of the matrix
     * @returns The row vectors
     * @public
     */
    getRowVectors(): Vector<S>[];
    /**
     * Returns a vector corresponding to the row at index `rowIndex`
     * @param i - The index for which to fetch the row
     * @returns The row vector
     * @public
     */
    getRow(i: number): Vector<S>;
    /**
     * An array of vectors corresponding to the columns of the matrix
     * @returns The column vectors
     * @public
     */
    getColumnVectors(): Vector<S>[];
    /**
     * Returns a vector corresponding to the column at index `columnIndex`
     * @param j - The index for which to fetch the column
     * @returns The column vector
     * @public
     */
    getColumn(j: number): Vector<S>;
    /**
     * Returns a vector containing the elements of the main diagonal of the matrix
     * @returns The vector of diagonal entries
     * @public
     */
    getDiagonal(): Vector<S>;
    /**
     * Returns the entry of the matrix at the specified indices `i` and `j`
     * @param rowIndex - The index of the row containing the entry
     * @param columnIndex - The index of the column containing the entry
     * @returns The entry
     * @public
     */
    getEntry(i: number, j: number): S;
    /**
     * Returns a new matrix equal to the old one, except with the entry at
     * `(i, j)` replaced with `value`
     *
     * @param rowIndex - The row containing the value to replace
     * @param columnIndex - The column containing the value to replace
     * @param value - The new value
     * @returns The new matrix
     * @public
     */
    set(i: number, j: number, value: S): Matrix<S>;
    /**
     * Implements matrix multiplication
     * @param other - The matrix by which to multiply
     * @returns The matrix product
     * @public
     */
    multiply(other: Matrix<S>): Matrix<S>;
    /**
     * Applies the matrix as a linear transformation to the given vector.
     * Implements matrix-vector multiplication.
     * @param vector - the vector that should be transformed by the matrix
     * @returns The transformed vector
     * @public
     */
    apply(vector: Vector<S>): Vector<S>;
    /**
     * Returns the adjoint of the matrix
     *
     * @remarks
     * The adjoint of a matrix A is the conjugate of the transpose of A
     *
     * @returns The adjoint
     * @public
     */
    adjoint(): Matrix<S>;
    /**
     * Returns the transpose of the matrix
     *
     * @remarks
     * The transpose of a matrix A is the unique matrix for which the entry
     * at `(i,j)` is equal to the entry in A at `(j, i)`
     *
     * @returns The transpose
     * @public
     */
    transpose(): Matrix<S>;
    /**
     * Returns the trace of the matrix
     *
     * @remarks
     * The trace of a matrix is the sum of the entries along the main diagonal
     *
     * @returns The trace
     * @public
     */
    trace(): S;
    /**
     * Implements matrix addition
     * @param other - The matrix to add
     * @returns The matrix sum
     * @public
     */
    add(other: Matrix<S>): Matrix<S>;
    /**
     * Implements multiplication of a matrix by a scalar
     * @param scalar - The scalar by which to multiply
     * @returns The product
     * @public
     */
    scalarMultiply(scalar: S): Matrix<S>;
    /**
     * Tests if two matrices are equal
     * @param other - The matrix against which to compare
     * @returns true if `this` is equal to `other`
     * @public
     */
    equals(other: Matrix<S>): boolean;
    /**
     * Executes the `callback` function for each entry in the matrix.
     * @param callback - The function to execute for each entry
     * @public
     */
    forEach(callback: (entry: S, rowIndex: number, columnIndex: number) => void): void;
    /**
     * Builds a matrix by transforming the values of the current matrix.
     *
     * @example
     * ```
     * const original = matrixBuilder.fromArray([
     *   [ 1, 2, 3 ]
     *   [ 4, 5, 6 ]
     * ]);
     *
     * const originalPlusOne = original.map(value => value + 1);
     *
     * // [ 2 3 4 ]
     * // [ 5 6 7 ]
     *
     * const originalPlusIMinusJ = original.map((value, i, j) => value + i - j);
     *
     * // [ 1 1 1 ]
     * // [ 5 5 5 ]
     * ```
     * @param entryFunction - A function which takes an entry of
     *     the original matrix and its indices, and returns the corresponding entry of the new matrix
     * @returns The new matrix
     * @public
     */
    map(entryFunction: (entry: S, rowIndex: number, columnIndex: number) => S): Matrix<S>;
    /**
     * Builds a matrix by combining element-wise the values of this matrix with the values of another matrix.
     *
     * @example
     * ```
     * const first = mat([
     *   [ 1, 2, 3 ]
     *   [ 4, 5, 6 ]
     * ]);
     *
     * const second = mat([
     *   [ 3, 4, 5 ]
     *   [ 6, 7, 8 ]
     * ]);
     *
     * const third = first.combine(second, (x, y) => x + y);
     * // [  4  6  8 ]
     * // [ 10 12 14 ]
     * ```
     * @param entryFunction - A function which takes an entry of
     *     the original matrix and its indices, and returns the corresponding entry of the new matrix
     * @returns The new matrix
     * @public
     */
    combine(other: Matrix<S>, combineEntries: (a: S, b: S) => S): Matrix<S>;
}

/**
 * Provides methods for constructing {@link Matrix | Matrices} of a given type
 * @public
 */
export declare class MatrixBuilder<S, V extends Vector<S>, M extends Matrix<S>> {
    private readonly _matrixConstructor;
    /**
     * @internal
     */
    constructor(matrixConstructor: MatrixConstructor<S, V, M>);
    fromArray(data: MatrixData<S>): M;
    fromNumberArray(numberData: MatrixData<number>): M;
    fromSparseData(shape: MatrixShape, sparseData: SparseMatrixData<S>): M;
    /**
     * Builds a matrix from an array of column vectors
     *
     * @example
     * ```
     * const firstColumn = vectorBuilder.fromArray([ 1, 2, 3 ]);
     * const secondColumn = vectorBuilder.fromArray([ 4, 5, 6 ]);
     *
     * const matrix = matrixBuilder.fromColumnVectors([ firstColumn, secondColumn ]);
     *
     * // [ 1 4 ]
     * // [ 2 5 ]
     * // [ 3 6 ]
     * ```
     * @param columns - The vectors to use as the columns of the new matrix
     * @public
     */
    fromColumnVectors(columns: Vector<S>[]): M;
    /**
     * Builds a matrix from an array of row vectors
     *
     * @example
     * ```
     * const firstRow = vectorBuilder.fromArray([ 1, 2, 3 ]);
     * const secondRow = vectorBuilder.fromArray([ 4, 5, 6 ]);
     *
     * const matrix = matrixBuilder.fromRowVectors([ firstRow, secondRow ]);
     *
     * // [ 1 2 3 ]
     * // [ 4 5 6 ]
     * ```
     *
     * @param rows - The vectors to use as the rows of the new matrix
     * @returns The new matrix
     * @public
     */
    fromRowVectors(rows: Vector<S>[]): M;
    /**
     * Builds a matrix with entries given by _entry = f(i, j)_ where _f_ is `indexFunction`
     * and `i` and `j` are the indices of the element
     *
     * @example
     * ```
     * const matrix = matrixBuilder.fromIndexFunction(3, 4, (i, j) => i + j + 3);
     *
     * // [ 3 4 5 6 ]
     * // [ 4 5 6 7 ]
     * // [ 5 6 7 8 ]
     * ```
     * @param shape - The shape of the matrix as a tuple
     * @param indexFunction - A function returning the entry for a given `i`, `j`
     * @returns The new matrix
     * @public
     */
    fromIndexFunction(shape: MatrixShape, indexFunction: (i: number, j: number) => S): M;
    /**
     * Constructs a 0x0 matrix
     *
     * @example
     * ```
     * matrixBuilder.empty(); // []
     * ```
     *
     * @public
     */
    empty(): M;
    /**
     * Constructs a matrix of the specified dimension, whose entries are all the specified value
     *
     * @example
     * ```
     * const allTwos = matrixBuilder.fill(2, 3, 4)
     *
     * // [ 2 2 2 2 ]
     * // [ 2 2 2 2 ]
     * // [ 2 2 2 2 ]
     * ```
     *
     * @param value - The value that should be used for every entry in the new matrix
     * @param shape - The shape of the matrix as a tuple
     * @returns The new matrix
     * @public
     */
    fill(value: S, shape: MatrixShape): M;
    /**
     * Constructs a matrix of the specified dimensions, consisting of all zeros
     *
     * @example
     * ```
     * const allZeros = matrixBuilder.zeros([2, 3]);
     *
     * // [ 0 0 0 ]
     * // [ 0 0 0 ]
     * ```
     * @param shape - the shape of the matrix as a tuple
     * @returns The new matrix
     * @public
     */
    zeros(shape: MatrixShape): M;
    /**
     * Constructs a matrix of the specified dimensions, consisting of all ones
     *
     * @example
     * ```
     * const allOnes = matrixBuilder.ones(2, 3);
     *
     * // [ 1 1 1 ]
     * // [ 1 1 1 ]
     * ```
     * @param shape - the shape of the matrix as a tuple
     * @returns The new matrix
     * @public
     */
    ones(shape: MatrixShape): M;
    /**
     * Constructs a `size` x `size` identity matrix
     *
     * @example
     * ```
     * const I3 = matrixBuilder.identity(3);
     *
     * // [ 1 0 0 ]
     * // [ 0 1 0 ]
     * // [ 0 0 1 ]
     * ```
     * @param size - The dimension of the vector space for which the new matrix is the identity
     * @returns The new matrix
     * @public
     */
    identity(size: number): M;
    /**
     * Constructs a Hilbert matrix of the specified size
     *
     * @example
     * ```
     * const H = matrixBuilder.hilbert(3);
     *
     * // [  1   1/2  1/3 ]
     * // [ 1/2  1/3  1/4 ]
     * // [ 1/3  1/4  1/5 ]
     * ```
     *
     * @param size - The size of the Hilbert matrix
     * @public
     */
    hilbert(size: number): M;
    /**
     * Constructs a Toeplitz matrix from the specified first column and first row.
     * A Toeplitz matrix has constant diagonals.  If `firstRow` is not given, then
     * the complex conjugate of `firstColumn` is assumed.  The first entry must be
     * real because the first entry of the first column must equal the first entry
     * of the first row.
     *
     * @example
     * ```
     * const toeplitz = matrixBuilder.toeplitz(vectorBuilder.fromArray([1, 2, 3]));
     *
     * // [ 1 2 3 ]
     * // [ 2 1 2 ]
     * // [ 3 2 1 ]
     *
     * const toeplitzWithSpecifiedRow = matrixBuilder.toeplitz(
     *   vectorBuilder.fromArray([1, 2, 3]),
     *   vectorBuilder.fromArray([1, 3, 5, 7])
     * );
     *
     * // [ 1 3 5 7 ]
     * // [ 2 1 3 5 ]
     * // [ 3 2 1 3 ]
     * ```
     *
     * @param firstColumn - The first column of the Toeplitz matrix
     * @param firstRow - The first row of the Toeplitz matrix
     * @public
     */
    toeplitz(firstColumn: Vector<S>, firstRow?: Vector<S>): M;
    /**
     * Constructs a Hankel matrix from the specified first column and last row.
     * A Hankel matrix has constant anti-diagonals. If `lastRow` is not given,
     * then a vector with the last entry of the first row in the first entry and
     * zero elsewhere is assumed.  The last entry of the first column must equal
     * the first entry of the last row.
     *
     * @example
     * ```
     * const hankel = matrixBuilder.hankel(vectorBuilder.fromArray([2, 4, 6, 8]));
     *
     * // [ 2 4 6 8 ]
     * // [ 4 6 8 0 ]
     * // [ 6 8 0 0 ]
     * // [ 8 0 0 0 ]
     *
     * const hankelWithSpecifiedRow = matrixBuilder.hankel(
     *   vectorBuilder.fromArray([1, 2, 3, 4]),
     *   vectorBuilder.fromArray([4, 9, 9])
     * );
     *
     * // [ 1 2 3 ]
     * // [ 2 3 4 ]
     * // [ 3 4 9 ]
     * // [ 4 9 9 ]
     * ```
     *
     * @param firstColumn - The first column of the Hankel matrix
     * @param lastRow - The last row of the Hankel matrix
     * @public
     */
    hankel(firstColumn: Vector<S>, lastRow?: Vector<S>): M;
    /**
     * Constructs a lower-triangular matrix whose entries are the binomial coefficients (j choose i).
     * Constructs an upper triangular matrix when the second argument is `true`.
     *
     * @example
     * ```
     * const pascalLower = matrixBuilder.pascal(4);
     *
     * // [ 1 0 0 0 ]
     * // [ 1 1 0 0 ]
     * // [ 1 2 1 0 ]
     * // [ 1 3 3 1 ]
     *
     * const pascalUpper = matrixBuilder.pascal(4, true);
     *
     * // [ 1 1 1 1 ]
     * // [ 0 1 2 3 ]
     * // [ 0 0 1 3 ]
     * // [ 0 0 0 1 ]
     * ```
     *
     * @param size - The size of the Pascal matrix
     * @param upper - Construct an upper-triangular matrix (i choose j)
     * @public
     */
    pascal(size: number, upper?: boolean): M;
    /**
     * Constructs a symmetric matrix whose entries are the binomial coefficients (i + j choose i)
     *
     * @example
     * ```
     * const pascalSymmetric = matrixBuilder.pascalSymmetric(4);
     *
     * // [ 1  1  1  1  ]
     * // [ 1  2  3  4  ]
     * // [ 1  3  6  10 ]
     * // [ 1  4  10 20 ]
     * ```
     *
     * @param size - The size of the Pascal matrix
     * @public
     */
    pascalSymmetric(size: number): M;
    /**
     * Construct a circulant matrix using entries from the input vector
     *
     * @example
     * ```
     * const circulant = matrixBuilder.circulant(vectorBuilder.fromArray([1, 2, 3]));
     *
     * // [ 1 3 2 ]
     * // [ 2 1 3 ]
     * // [ 3 2 1 ]
     * ```
     *
     * @param vector - The vector whose entries to use in the circulant matrix
     * @public
     */
    circulant(vector: Vector<S>): M;
    /**
     * Constructs a matrix of the specified size whose entries are (uniformly-distributed) random
     * numbers between `min` and `max`
     *
     * @param shape - The shape of the matrix as a tuple
     * @param min - The lower limit of the random numbers to include
     * @param max - The upper limit of the random numbers to include
     * @public
     */
    random(shape: MatrixShape, min?: number, max?: number): M;
    /**
     * Constructs a matrix of the specified size whose entries are normally distributed with the
     * specified mean and standard deviation.
     *
     * @param shape - The shape of the matrix as a tuple
     * @param mean - The center of the distribution of random numbers to include
     * @param standardDeviation - The standard deviation of the distribution of random numbers to include
     * @public
     */
    randomNormal(shape: MatrixShape, mean?: number, standardDeviation?: number): M;
    /**
     * Constructs a square diagonal matrix whose diagonal entries come from `diagonalEntries`
     *
     * @example
     * ```
     * const diagonalEntries = NumberVector.fromValues(1, 2, 3);
     * matrixBuilder.diagonal(diagonalEntries);
     *
     * // [ 1 0 0 ]
     * // [ 0 2 0 ]
     * // [ 0 0 3 ]
     * ```
     * @param diagonalEntries - A vector whose entries will be used as the diagonal entries of the new matrix
     * @returns The new matrix
     * @public
     */
    diagonal(diagonalEntries: Vector<S>): M;
    /**
     * Constructs a square tridiagonal matrix whose diagonal entries correspond to the entries of
     * `diagonalEntries`, whose entries in the left-off-diagonal correspond to the entries
     * of `leftEntries`, and whose entries in the right-off-diagonal correspond fo the
     * entries of `rightEntries`.
     * The off-diagonals must have one fewer entry than the diagonal.
     * Throws an error if the dimensions are not correct.
     *
     * @example
     * ```
     * const leftEntries = NumberVector.fromEntries(1, 2);
     * const diagonalEntries = NumberVector.fromEntries(3, 4, 5);
     * const rightEntries = NumberVector.fromEntries(6, 7);
     *
     * const tridiagonal = matrixBuilder.tridiagonal(leftEntries, diagonalEntries, rightEntries);
     *
     * // [ 3 6 0 ]
     * // [ 1 4 7 ]
     * // [ 0 2 5 ]
     * ```
     *
     * @param leftEntries - A vector whose entries will be used in the left off-diagonal
     * @param diagonalEntries - A vector whose entries will be used in the diagonal
     * @param rightEntries - A vector whose entries will be used in the right off-diagonal
     * @returns The new matrix
     * @public
     */
    tridiagonal(leftEntries: Vector<S>, diagonalEntries: Vector<S>, rightEntries: Vector<S>): M;
    /**
     * Creates a block-diagonal matrix.
     *
     * @example
     * ```
     * const ones = matrixBuilder.ones(2);
     * const twos = matrixBuilder.fill(2, 3);
     *
     * const blockDiagonal = matrixBuilder.blockDiagonal([ones, twos, ones]);
     *
     * // [ 1 1 0 0 0 0 0 ]
     * // [ 1 1 0 0 0 0 0 ]
     * // [ 0 0 2 2 2 0 0 ]
     * // [ 0 0 2 2 2 0 0 ]
     * // [ 0 0 2 2 2 0 0 ]
     * // [ 0 0 0 0 0 1 1 ]
     * // [ 0 0 0 0 0 1 1 ]
     * ```
     *
     * @param matrices - The matrices to appear along the primary diagonal of the block matrix
     * @public
     */
    blockDiagonal(matrices: Matrix<S>[]): M;
    /**
     * Constructs a single matrix consisting of a grid of matrices combined together.
     * Throws an error if any of the dimensions are incompatible.
     *
     * @example
     * ```
     * const upperLeft = matrixBuilder.ones(1, 1);
     * const upperRight = matrixBuilder.fill(2, 1, 2);
     * const lowerLeft = matrixBuilder.fill(3, 2, 1);
     * const lowerRight = matrixBuilder.fill(4, 2, 2);
     *
     * const grid = [
     *   [ upperLeft, upperRight ],
     *   [ lowerLeft, lowerRight ]
     * ];
     *
     * const block = matrixBuilder.block(grid);
     *
     * // [ 1 2 2 ]
     * // [ 3 4 4 ]
     * // [ 3 4 4 ]
     * ```
     * @param grid - A 2-dimensional array of matrices that will be combined into the new matrix
     * @returns The new matrix
     * @public
     */
    block(grid: Matrix<S>[][]): M;
    /**
     * Constructs a new matrix consisting of `left` and `right` next to one another.
     * Throws an error of `left` and `right` do not have the same number of rows.
     *
     * @example
     * ```
     * const left = matrixBuilder.ones(2);
     * const right = matrixBuilder.zeros(2, 3);
     *
     * matrixBuilder.augment(left, right);
     *
     * // [ 1 1 0 0 0 ]
     * // [ 1 1 0 0 0 ]
     * ```
     * @param left - The matrix that will form the left-side of the augmented matrix
     * @param right - The matrix that will form the right-side of the augmented matrix
     * @returns The new augmented matrix
     * @public
     */
    augment(left: Matrix<S>, right: Matrix<S>): M;
    /**
     * Constructs a new matrix consisted of repetitions of a smaller matrix.
     *
     * @example
     * ```
     * const I = matrixBuilder.identity(2);
     * const repeated = matrixBuilder.repeat(I, 1, 2);
     *
     * // [ 1 0 1 0 ]
     * // [ 0 1 0 1 ]
     * ```
     * @param matrix - The matrix to be repeated
     * @param rows - The number of times to repeat the matrix vertically
     * @param columns - The number of times to repeat the matrix horizontally
     * @returns The new matrix
     * @public
     */
    repeat(matrix: Matrix<S>, rows: number, columns: number): M;
    /**
     * Constructs a new matrix based on a rectangular slice of a larger matrix
     *
     * @example
     * ```
     * const matrix = matrixBuilder.identity(4);
     * const slice = matrixBuilder.slice(matrix, 2, 2, 3, 4);
     *
     * // [  1  0  0  0  ]
     * // [  0  1* 0* 0* ]  =>  [ 1 0 0 ]
     * // [  0  0* 1* 0* ]      [ 0 1 0 ]
     * // [  0  0  0  1  ]
     * ```
     *
     * @param matrix - The original matrix
     * @param rowStartIndex - The (inclusive) first row of the slice
     * @param columnStartIndex - The (inclusive) first column of the slice
     * @param rowEndIndex - The (exclusive) last row of the slice
     * @param columnEndIndex - The (exclusive) last column of the slice
     * @returns The new matrix
     * @public
     */
    slice(matrix: Matrix<S>, rowStartIndex?: number, columnStartIndex?: number, rowEndIndex?: number, columnEndIndex?: number): M;
    /**
     * Constructs a new matrix with all entries in row `rowToExclude` and in
     * column `columnToExclude` removed.
     *
     * @example
     * ```
     * const I = matrixBuilder.identity(4);
     * const excluded = matrixBuilder.slice(I, 1, 2)
     *
     * // [  1  0  0* 0  ]
     * // [  0* 1* 0* 0* ]  =>  [ 1 0 0 ]
     * // [  0  0  1* 0  ]      [ 0 0 0 ]
     * // [  0  0  0* 1  ]      [ 0 0 1 ]
     * ```
     * @param matrix - The input matrix
     * @param rowToExclude - The index of the row that will be removed
     * @param columnToExclude - The index of the column that will be removed
     * @returns The new matrix
     * @public
     */
    exclude(matrix: Matrix<S>, rowToExclude: number, columnToExclude: number): M;
    private ops;
    /**
     * Constructs a new matrix consisting of `top` and `bottom` on top of one another.
     * Throws an error if `top` and `bottom` do not have the same number of columns.
     *
     * @example
     * ```
     * const top = matrixBuilder.ones(2, 3);
     * const bottom = matrixBuilder.zeros(1,3);
     *
     * matrixBuilder.stack(top, bottom);
     *
     * // [ 1 1 1 ]
     * // [ 1 1 1 ]
     * // [ 0 0 0 ]
     * ```
     * @param top - The matrix that will be used for the top half of the new matrix
     * @param bottom - The matrix that will be used for the bottom half of the new matrix
     * @returns The new matrix
     * @public
     */
    private stack;
}

/**
 * @internal
 */
export declare interface MatrixConstructor<S, V extends Vector<S>, M extends Matrix<S>> {
    new (data: MatrixData<S>): M;
    ops(): ScalarOperations<S>;
    builder(): MatrixBuilder<S, V, M>;
    vectorBuilder(): VectorBuilder<S, V>;
}

/**
 * The data stored in a {@link Matrix} represented as a 2-D array
 * @public
 */
export declare type MatrixData<S> = readonly VectorData<S>[];

/**
 * A function that generates a matrix entry based on an existing entry `entry`,
 * its row index `i`, and its column index `j`
 *
 * @remarks
 * This should be a pure function
 *
 * @public
 */
export declare type MatrixEntryFunction<S> = (entry: S, i: number, j: number) => S;

/**
 * A tuple representing the shape of a {@link Matrix}.
 * The first entry is the number of rows, and the second entry is the number of columns.
 * @public
 */
export declare type MatrixShape = [number, number];

/**
 * Calculates the mean of the values in the vector `x`
 * @param x - The vector for which to find the mean
 * @public
 */
export declare function mean<S>(x: Vector<S>): S;

/**
 * Calculates the mean vector of the matrix `A`
 * @remarks
 * The mean vector of a matrix is a vector of the means of the matrix columns
 * @param A - The matrix for which to find the mean vector
 * @public
 */
export declare function mean<S>(A: Matrix<S>): Vector<S>;

/**
 * A function that calculates a norm for a vector.
 *
 * @remarks
 * A `Norm` should satisfy:
 * - `norm(v)` is greater than 0 when `v` is not the zero vector
 * - `norm(v)` equals 0 when `v` is the zero vector
 * - `norm(k * v)` equals `k * norm(v)`
 * - `norm(v + w)` is less than or equal to `norm(v) + norm(w)` (the triangle inequality)
 *
 * @public
 */
export declare type Norm<S = number> = (v: Vector<S>) => number;

/**
 * Returns a vector with the same direction as the input `v`, but with a Euclidean norm of 1
 *
 * @example
 * ```
 * const v = vec(3, 4);
 * const normalized = normalize(v); // [ 0.6, 0.8 ]
 * ```
 *
 * @param v - The vector to normalize
 * @public
 */
export declare function normalize<S>(v: Vector<S>): Vector<S> | undefined;

/**
 * A dense matrix of JavaScript `number` primitives, implemented as an {@link ArrayMatrix}
 * @public
 */
export declare class NumberMatrix extends ArrayMatrix<number> {
    static ops(): ScalarOperations<number>;
    static builder(): MatrixBuilder<number, NumberVector, NumberMatrix>;
    static vectorBuilder(): VectorBuilder<number, NumberVector>;
    /**
     * @internal
     */
    constructor(data: MatrixData<number>);
    /**
     * {@inheritDoc ArrayMatrix.ops}
     */
    ops(): ScalarOperations<number>;
    /**
     * {@inheritDoc ArrayMatrix.builder}
     */
    builder(): MatrixBuilder<number, NumberVector, NumberMatrix>;
    /**
     * {@inheritDoc ArrayMatrix.vectorBuilder}
     */
    vectorBuilder(): VectorBuilder<number, NumberVector>;
}

/**
 * Implements the basic {@link ScalarOperations} on `number`s
 * @public
 */
export declare class NumberOperations extends ScalarOperations<number> {
    /**
     * {@inheritdoc ScalarOperations.fromNumber}
     */
    fromNumber(num: number): number;
    /**
     * {@inheritdoc ScalarOperations.add}
     */
    add(first: number, second: number): number;
    /**
     * {@inheritdoc ScalarOperations.conjugate}
     */
    conjugate(scalar: number): number;
    /**
     * {@inheritdoc ScalarOperations.getAdditiveIdentity}
     */
    getAdditiveIdentity(): number;
    /**
     * {@inheritdoc ScalarOperations.getAdditiveInverse}
     */
    getAdditiveInverse(x: number): number;
    /**
     * {@inheritdoc ScalarOperations.getMultiplicativeIdentity}
     */
    getMultiplicativeIdentity(): number;
    /**
     * {@inheritdoc ScalarOperations.getMultiplicativeInverse}
     */
    getMultiplicativeInverse(x: number): number | undefined;
    /**
     * {@inheritdoc ScalarOperations.getPrincipalSquareRoot}
     */
    getPrincipalSquareRoot(x: number): number | undefined;
    /**
     * {@inheritdoc ScalarOperations.norm}
     */
    norm(x: number): number;
    /**
     * {@inheritdoc ScalarOperations.multiply}
     */
    multiply(first: number, second: number): number;
    /**
     * {@inheritdoc ScalarOperations.equals}
     */
    equals(first: number, second: number): boolean;
    /**
     * {@inheritdoc ScalarOperations.random}
     */
    random(min?: number, max?: number): number;
    /**
     * {@inheritdoc ScalarOperations.randomNormal}
     */
    randomNormal(mean?: number, standardDeviation?: number): number;
    /**
     * {@inheritdoc ScalarOperations.prettyPrint}
     */
    prettyPrint(x: number): string;
}

/**
 * A dense {@link Vector} of `number`s implemented as a {@link ArrayVector}
 * @public
 */
export declare class NumberVector extends ArrayVector<number> {
    static ops(): NumberOperations;
    static builder(): VectorBuilder<number, NumberVector>;
    /**
     * @internal
     */
    constructor(data: VectorData<number>);
    /**
     * {@inheritDoc ArrayVector.ops}
     */
    ops(): NumberOperations;
    /**
     * {@inheritDoc ArrayVector.builder}
     */
    builder(): VectorBuilder<number, NumberVector>;
    /**
     * {@inheritDoc ArrayVector.matrixBuilder}
     */
    matrixBuilder(): MatrixBuilder<number, NumberVector, NumberMatrix>;
}

/**
 * Creates a new vector of all 1s.  See {@link VectorBuilder.ones}
 * @public
 */
export declare function ones(entries: number): Vector;

/**
 * Creates a new matrix of all 1s.  See {@link MatrixBuilder.ones}
 * @public
 */
export declare function ones(shape: MatrixShape): Matrix;

declare interface OverdeterminedSolution {
    solutionType: SolutionType.OVERDETERMINED;
}

/**
 * Conducts a principal component analysis of a matrix `A`, and returns `A` in a new basis
 * corresponding to the principal components.
 * @param A - The matrix to analyze
 * @param useCorrelation - Whether to use correlation rather than covariance to determine
 *     principal components.  Equivalently, whether to standardize rather than merely center
 *     the data.  This option should be used if the variables in the data naturally fall on
 *     different scales.
 * @public
 */
export declare function pca<S>(A: Matrix<S>, useCorrelation?: boolean): PrincipalComponentAnalysis<S>;

/**
 * Calculates the P-Norm of a vector `v`
 *
 * @example
 * ```
 * const v = vec([3, 4]);
 * const norm1 = pNorm(v, 1); // 7
 * const norm2 = pNorm(v, 2); // 5
 * const norm3 = pNorm(v, 3); // 4.49794...
 * ```
 *
 * @param v - The vector for which to calculate the norm
 * @param p - The power used to calculate the norm
 * @public
 */
export declare function pNorm<S>(v: Vector<S>, p: number): number;

/**
 * Computes _A^n_ recursively.
 *
 * @param A - The matrix to raise to a power `n`
 * @param n - The power to which to raise `A`
 * @public
 */
export declare function pow<S>(A: Matrix<S>, n: number): Matrix<S>;

/**
 * Returns an easy-to-read string representing a `number`
 * @public
 */
export declare function prettyPrint(num: number): string;

/**
 * Returns an easy-to-read string representing the contents of a {@link Vector}
 * @public
 */
export declare function prettyPrint<S>(vector: Vector<S>): string;

/**
 * Returns an easy-to-read string representing the contents of a {@link Matrix}
 * @public
 */
export declare function prettyPrint<S>(matrix: Matrix<S>): string;

/**
 * The result of a principal component analysis.
 * @public
 */
export declare interface PrincipalComponentAnalysis<S> {
    /**
     * The directions in which the data varies the most, ordered by
     * the proportion of variation explained by each direction
     */
    principalComponents: Vector<S>[];
    /**
     * The variances in the directions of the corresponding principal components
     */
    variances: S[];
    /**
     * The proportion of the total variance explained by each principal component
     */
    proportions: S[];
    /**
     * The proportion of the total variance explained by the first k components
     */
    cumulativeProportions: S[];
    /**
     * The original data in a basis formed by the principal component vectors
     */
    coordinates: Matrix<S>;
}

/**
 * The result of a QR decomposition.
 * @public
 */
export declare interface QRDecomposition<S> {
    Q: Matrix<S>;
    R: Matrix<S>;
}

/**
 * Creates a {@link Kernel} for use in a {@link SupportVectorMachineClassifier}.
 * The RBF kernel converts a data {@link Matrix} into a similarity `Matrix`
 * where the value of entry (i,j) expresses the similarity of rows i and j in
 * the original data set.
 *
 * @param distanceMetric - A {@link SimilarityMetric} which defines how the RBF
 *     kernel expresses the similarity between two vectors.
 *
 * @public
 */
export declare function RadialBasisFunction(distanceMetric: SimilarityMetric): Kernel;

/**
 * Calculates the rank of a matrix
 *
 * @remarks
 * The rank of a matrix A is the dimension of the vector space spanned by the columns of A.
 * Equivalently, it is the number of pivot entries in the row-echelon form of A, or the number
 * of nonzero rows in the row echelon form of A.
 *
 * @param matrix - the matrix for which to determine the rank
 * @public
 */
export declare function rank<S>(matrix: Matrix<S>): number;

/**
 * Reduce the number of dimensions of a data matrix `A` while losing as little information as possible.
 * @param A - The data matrix
 * @param options - Specify how the dimension reduction should be done.
 *     `useCorrelation: boolean` - use the correlation rather than covariance matrix when conducting the PCA;
 *     `keep: number` - the desired number of dimensions;
 *     `remove: number` - the number of dimensions to remove;
 *     `proportionOfVariance: number` - the desired proportion of the total variance in the data that should
 *          be explained by the remaining columns
 * @public
 */
export declare function reduceDimensions(A: Matrix, options: DimensionReductionOptions): Matrix;

/**
 * Uses Gauss-Jordan elimination with pivoting to convert a matrix to Reduced Row-Echelon Form (RREF)
 *
 * @param matrix - The input matrix
 * @returns The matrix in RREF
 * @public
 */
export declare function reducedRowEchelonForm<S>(matrix: Matrix<S>): Matrix<S>;

/**
 * A machine learning model with a continuous numeric target
 * @public
 */
export declare interface Regressor<H> {
    /**
     * Learns the optimal set of parameters for the model.
     *
     * @param data - A {@link Matrix} whose rows are the individual observations in the training set
     * @param target - A {@link Vector} whose entries are the target values in the training set
     * @public
     */
    train(data: Matrix, target: Vector): void;
    /**
     * Uses the learned parameters to make predictions based on a set of input data.
     *
     * @remarks
     * Must be called after {@link Regressor.train}
     *
     * @param data - A {@link Vector} whose rows are the observations in the test set
     * @public
     */
    predict(data: Matrix): Vector;
    /**
     * Return the full set of hyperparameters used to train the model, including defaults.
     * @public
     */
    getHyperParameters(): H;
}

/**
 * Uses Gauss-Jordan elimination with pivoting to convert a matrix to Row-Echelon Form (REF)
 *
 * @param matrix - The input matrix
 * @returns The matrix in REF
 * @public
 */
export declare function rowEchelonForm<S>(matrix: Matrix<S>): Matrix<S>;

/**
 * The result of a row operation (`result`), and the matrix that we multiply
 * by the original matrix to yield that result (`operator`)
 * @public
 */
export declare interface RowOperationResult<S> {
    result: Matrix<S>;
    operator: Matrix<S>;
}

/**
 * A wrapper for static methods representing the elementary row operations
 * @public
 */
export declare class RowOperations {
    /**
     * An elementary row operations which returns a new matrix whose row
     * at `rowIndex` is multiplied by `scalar`
     *
     * @param matrix - The original matrix
     * @param rowIndex - The index of the row to modify
     * @param scalar - The factor by which to scale the row
     * @returns The matrix with the transformation applied
     * @public
     */
    static multiplyRowByScalar<S>(matrix: Matrix<S>, rowIndex: number, scalar: S): Matrix<S>;
    /**
     * An elementary row operations which returns a new matrix whose row at `targetRow` has
     * had the row at `rowToAdd` added to it.
     *
     * @param matrix - The original matrix
     * @param targetRow - The index of the row to modify
     * @param rowToAdd - The index of the row to add
     * @returns The matrix with the transformation applied
     * @public
     */
    static addRowToRow<S>(matrix: Matrix<S>, targetRow: number, rowToAdd: number): Matrix<S>;
    /**
     * An elementary row operations which returns a new matrix whose row at `targetRow` has
     * had a scalar multiple of `rowToAdd` added to it.
     *
     * @param matrix - The original matrix
     * @param targetRow - The index of the row to modify
     * @param rowToAdd - The index of the row to be scaled and added
     * @param scalar - The factor by which to scale the row
     * @returns The matrix with the transformation applied
     * @public
     */
    static addScalarMultipleOfRowToRow<S>(matrix: Matrix<S>, targetRow: number, rowToAdd: number, scalar: S): Matrix<S>;
    /**
     * An elementary row operations which returns a new matrix whose row at index `first` has
     * been exchanged with the row at index `second`
     *
     * @param matrix - The original matrix
     * @param first - The index of the first row to exchange
     * @param second - The index of the second row to exchange
     * @returns The matrix with the transformation applied
     * @public
     */
    static exchangeRows<S>(matrix: Matrix<S>, first: number, second: number): Matrix<S>;
    /**
     * Sorts the rows of a matrix according to the number of leading zeros
     * and the magnitude of the first nonzero entry
     * @public
     */
    static pivot<S>(matrix: Matrix<S>): RowOperationResult<S>;
}

/**
 * Calculates the Infinity-Norm of a matrix `A`
 *
 * @example
 * ```
 * const A = mat([[1, 2], [3, 4]]);
 * const norm = rowSumSupremumNorm(A); // 7
 * ```
 *
 * @param A - The matrix for which to calculate the norm
 * @public
 */
export declare function rowSumSupremumNorm<S>(A: Matrix<S>): number;

/**
 * A class which encapsulates the basic arithmetic operations for an arbitrary scalar type.
 *
 * @remarks
 * This must be implemented for each scalar to be used in a {@link Vector} or {@link Matrix}
 * @public
 */
export declare abstract class ScalarOperations<S> {
    /**
     * Returns an instance of the scalar type which most accurately corresponds to the value of `num`
     * @returns The scalar
     * @public
     */
    abstract fromNumber(num: number): S;
    /**
     * Returns an instance of the scalar type from its real and imaginary parts.  If the scalar
     * type does not support complex numbers, then an error will be thrown.
     * @returns The scalar
     * @public
     */
    fromComplex(real: number, imaginary: number): S;
    /**
     * Tests if the scalars are equal.
     * Implementors should ensure that the operation is reflexive, associative, and transitive.
     *
     * @returns true if `first` is equal to `second`
     * @public
     */
    abstract equals(first: S, second: S): boolean;
    /**
     * Returns the sum of two scalars `first` and `second`.
     *
     * @remarks
     * Implementors should ensure that this operation is commutative and associative.
     *
     * @returns The sum
     * @public
     */
    abstract add(first: S, second: S): S;
    /**
     * Returns the difference of two scalars.
     *
     * @returns The difference
     * @public
     */
    subtract(first: S, second: S): S;
    /**
     * Returns the product of two scalars `first` and `second`.
     *
     * @remarks
     * Implementors should ensure that this operation is commutative and associative,
     * and that it distributes over the addition operation.
     *
     * @returns The product of `first` and `second`
     * @public
     */
    abstract multiply(first: S, second: S): S;
    /**
     * Returns the quotient of two scalars `numerator` and `denominator`,
     * or `undefined` if the quotient does not exist.
     *
     * @returns The quotient
     */
    divide(numerator: S, denominator: S): S | undefined;
    /**
     * Returns the complex conjugate of a scalar.
     *
     * @remarks
     * For real-valued scalars, this can just be an identity function.
     *
     * @param scalar - The scalar to conjugate
     * @returns The complex conjugate
     * @public
     */
    abstract conjugate(scalar: S): S;
    /**
     * Returns the unique scalar that, when added to another scalar, returns that scalar
     *
     * @remarks
     * In other words,
     * `addScalars(x, getAdditiveIdentity()) === x`
     * is true for all scalars `x`
     *
     * @returns The additive identity
     * @public
     */
    abstract getAdditiveIdentity(): S;
    /**
     * Alias for {@link ScalarOperations.getAdditiveIdentity}
     */
    zero(): S;
    /**
     * Returns the unique value that, when added to `x`, returns the additive identity
     *
     * @remarks
     * In other words,
     * `addScalars(scalar, getAdditiveInverse(scalar)) === getAdditiveIdentity()`
     * is true for `x`
     *
     * @returns The additive inverse
     * @public
     */
    abstract getAdditiveInverse(x: S): S;
    /**
     * Returns the unique scalar that, when multiplied by another scalar, returns that scalar
     *
     * @remarks
     * In other words,
     * `multiplyScalars(x, getMultiplicativeIdentity()) === x`
     * is true for all x
     *
     * @returns The multiplicative identity
     * @public
     */
    abstract getMultiplicativeIdentity(): S;
    /**
     * Alias for {@link ScalarOperations.getMultiplicativeIdentity}
     * @public
     */
    one(): S;
    /**
     * Returns the additive inverse of the multiplicative identity.
     *
     * @public
     */
    negativeOne(): S;
    /**
     * Returns the unique scalar that, when multiplied by `scalar`,
     * returns the multiplicative identity
     *
     * @example
     * ```
     * multiplyScalars(scalar, getMultiplicativeInverse(scalar)) === getMultiplicativeIdentity()
     * ```
     *
     * is true for `scalar`
     *
     * @returns The multiplicative inverse
     * @public
     */
    abstract getMultiplicativeInverse(x: S): S | undefined;
    /**
     * Returns the principal square root of a scalar.
     *
     * @remarks
     * For real-valued scalar types, this should be the positive square root.
     * For complex-values scalar types, this should be the root with a positive real part.
     *
     * @returns The square root
     * @public
     */
    abstract getPrincipalSquareRoot(x: S): S | undefined;
    /**
     * Returns the norm (absolute value or magnitude) of a scalar
     * @returns The norm
     * @public
     */
    abstract norm(x: S): number;
    /**
     * Returns a random scalar value between `min` and `max`
     *
     * @remarks
     * This might not be a meaningful value for non-real-values scalar types
     *
     * @returns The random scalar
     * @public
     */
    abstract random(min: number, max: number): S;
    /**
     * Returns a random scalar value from a normal distribution centered on `mean`
     * with standard deviation `standardDeviation`
     *
     * @remarks
     * This might not be a meaningful value for non-real-valued scalar types
     *
     * @returns The random scalar
     * @public
     */
    abstract randomNormal(mean: number, standardDeviation: number): S;
    /**
     * Returns a readable string that represents the value of the scalar
     * @returns The readable string
     * @public
     */
    abstract prettyPrint(x: S): string;
}

/**
 * A function which expresses the similarity of two {@link Vector}s as a number between
 * 0 (very dissimilar) and 1 (identical).
 *
 * @public
 */
export declare type SimilarityMetric = (v1: Vector, v2: Vector) => number;

/**
 * The result of a Singular Value Decomposition
 * @public
 */
export declare interface SingularValueDecomposition<S> {
    U: Matrix<S>;
    Sigma: Matrix<S>;
    V: Matrix<S>;
}

declare enum SolutionType {
    UNIQUE = "Unique",
    UNDERDETERMINED = "Underdetermined",
    OVERDETERMINED = "Overdetermined"
}

/**
 * Uses Gauss-Jordan elimination with pivoting and backward substitution
 * to solve the linear equation _Ax=b_
 *
 * @param A - The matrix _A_ in _Ax=b_
 * @param b - The vector _b_ in _Ax=b_
 * @returns The vector _x_ in _Ax=b_
 * @public
 */
export declare function solveByGaussianElimination<S>(A: Matrix<S>, b: Vector<S>): LinearSolution<S>;

/**
 * Gives an approximate solution to an overdetermined linear system.
 *
 * @remarks
 * When the system _Ax = b_ is overdetermined, it has no solution.
 * However, there exists a unique vector _x_ which minimizes the  difference Ax-b,
 * which solves `A.transpose().multiply(A).apply(x) === A.transpose().apply(b)`
 *
 * @param A - The matrix _A_ in _Ax = b_
 * @param b - The vector _b_ in _Ax = b_
 * @public
 */
export declare function solveOverdeterminedSystem<S>(A: Matrix<S>, b: Vector<S>): Vector<S>;

/**
 * Implements {@link Matrix} with a map of indices to nonzero values.
 *
 * @remarks
 * Subclasses must specify the usual scalar operations on their contents.
 *
 * @public
 */
export declare abstract class SparseMatrix<S = number> implements Matrix<S> {
    private readonly _shape;
    private readonly _sparseData;
    /**
     * @internal
     */
    protected constructor(data: MatrixData<S>);
    /**
     * {@inheritdoc Matrix.ops}
     */
    abstract ops(): ScalarOperations<S>;
    /**
     * {@inheritdoc Matrix.builder}
     */
    abstract builder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    /**
     * {@inheritdoc Matrix.vectorBuilder}
     */
    abstract vectorBuilder(): VectorBuilder<S, Vector<S>>;
    /**
     * {@inheritDoc Matrix.add}
     */
    add(other: Matrix<S>): Matrix<S>;
    /**
     * {@inheritDoc Matrix.adjoint}
     */
    adjoint(): Matrix<S>;
    /**
     * {@inheritDoc Matrix.trace}
     */
    trace(): S;
    /**
     * {@inheritDoc Matrix.apply}
     */
    apply(vector: Vector<S>): Vector<S>;
    /**
     * {@inheritDoc Matrix.equals}
     */
    equals(other: Matrix<S>): boolean;
    /**
     * {@inheritDoc Matrix.getColumn}
     */
    getColumn(j: number): Vector<S>;
    /**
     * {@inheritDoc Matrix.getColumnVectors}
     */
    getColumnVectors(): Vector<S>[];
    /**
     * {@inheritDoc Matrix.getDiagonal}
     */
    getDiagonal(): Vector<S>;
    /**
     * {@inheritDoc Matrix.toArray}
     */
    toArray(): S[][];
    /**
     * {@inheritDoc Matrix.getSparseData}
     */
    getSparseData(): Map<number, Map<number, S>>;
    /**
     * {@inheritDoc Matrix.getEntry}
     */
    getEntry(i: number, j: number): S;
    /**
     * {@inheritDoc Matrix.getShape}
     */
    getShape(): MatrixShape;
    /**
     * {@inheritDoc Matrix.getNumberOfColumns}
     */
    getNumberOfColumns(): number;
    /**
     * {@inheritDoc Matrix.getNumberOfRows}
     */
    getNumberOfRows(): number;
    /**
     * {@inheritDoc Matrix.getRow}
     */
    getRow(i: number): Vector<S>;
    /**
     * {@inheritDoc Matrix.getRowVectors}
     */
    getRowVectors(): Vector<S>[];
    /**
     * {@inheritDoc Matrix.multiply}
     */
    multiply(other: Matrix<S>): Matrix<S>;
    /**
     * {@inheritDoc Matrix.scalarMultiply}
     */
    scalarMultiply(scalar: S): Matrix<S>;
    /**
     * {@inheritDoc Matrix.set}
     */
    set(i: number, j: number, value: S): Matrix<S>;
    /**
     * {@inheritDoc Matrix.transpose}
     */
    transpose(): Matrix<S>;
    /**
     * {@inheritDoc Matrix.forEach}
     */
    forEach(cb: (entry: S, rowIndex: number, columnIndex: number) => void): void;
    /**
     * {@inheritDoc Matrix.map}
     */
    map(entryFunction: (entry: S, rowIndex: number, columnIndex: number) => S): Matrix<S>;
    /**
     * {@inheritDoc Matrix.combine}
     */
    combine(other: Matrix<S>, combineEntries: (a: S, b: S) => S): Matrix<S>;
}

/**
 * The data stored in a {@link Matrix} represented as a map
 * @public
 */
export declare type SparseMatrixData<S> = ReadonlyMap<number, ReadonlyMap<number, S>>;

/**
 * A {@link Matrix} implemented as a sparse set of JS `number` primitives keyed by their indices.
 * @public
 */
export declare class SparseNumberMatrix extends SparseMatrix<number> {
    static ops(): ScalarOperations<number>;
    static builder(): MatrixBuilder<number, SparseNumberVector, SparseNumberMatrix>;
    static vectorBuilder(): VectorBuilder<number, SparseNumberVector>;
    /**
     * @internal
     */
    constructor(data: MatrixData<number>);
    /**
     * {@inheritDoc SparseMatrix.ops}
     */
    ops(): ScalarOperations<number>;
    /**
     * {@inheritDoc SparseMatrix.builder}
     */
    builder(): MatrixBuilder<number, SparseNumberVector, SparseNumberMatrix>;
    /**
     * {@inheritDoc SparseMatrix.vectorBuilder}
     */
    vectorBuilder(): VectorBuilder<number, SparseNumberVector>;
}

/**
 * A {@link Vector} implemented as a sparse set of JS `number` primitives keyed by their indices.
 * @public
 */
export declare class SparseNumberVector extends SparseVector<number> {
    static ops(): ScalarOperations<number>;
    static builder(): VectorBuilder<number, SparseNumberVector>;
    /**
     * @internal
     */
    constructor(data: VectorData<number>);
    /**
     * {@inheritDoc SparseVector.ops}
     */
    ops(): ScalarOperations<number>;
    /**
     * {@inheritDoc SparseVector.builder}
     */
    builder(): VectorBuilder<number, SparseNumberVector>;
    /**
     * {@inheritDoc SparseVector.matrixBuilder}
     */
    matrixBuilder(): MatrixBuilder<number, SparseNumberVector, SparseNumberMatrix>;
}

/**
 * Implements {@link Vector} as a map of indices to nonzero values.
 *
 * @remarks
 * For large vectors with many entries equal to 0, some operations are
 * more efficient with a {@link Vector} implementation that only stores the non-zero values.
 *
 * Subclasses must specify the usual scalar operations on their contents.
 *
 * @public
 */
export declare abstract class SparseVector<S = number> implements Vector<S> {
    private readonly _dimension;
    private readonly _sparseData;
    /**
     * @internal
     */
    protected constructor(data: VectorData<S>);
    abstract ops(): ScalarOperations<S>;
    abstract builder(): VectorBuilder<S, Vector<S>>;
    abstract matrixBuilder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    /**
     * {@inheritDoc Vector.getSparseData}
     */
    getSparseData(): Map<number, S>;
    /**
     * {@inheritDoc Vector.toArray}
     */
    toArray(): S[];
    /**
     * {@inheritDoc Vector.getEntry}
     */
    getEntry(index: number): S;
    /**
     * {@inheritDoc Vector.set}
     */
    set(index: number, value: S): Vector<S>;
    /**
     * {@inheritDoc Vector.innerProduct}
     */
    innerProduct(other: Vector<S>): S;
    /**
     * {@inheritDoc Vector.outerProduct}
     */
    outerProduct(other: Vector<S>): Matrix<S>;
    /**
     * {@inheritDoc Vector.scalarMultiply}
     */
    scalarMultiply(scalar: S): Vector<S>;
    /**
     * {@inheritDoc Vector.add}
     */
    add(other: Vector<S>): Vector<S>;
    /**
     * {@inheritDoc Vector.equals}
     */
    equals(other: Vector<S>): boolean;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    getDimension(): number;
    /**
     * {@inheritDoc Vector.projectOnto}
     */
    projectOnto(u: Vector<S>): Vector<S>;
    private equalsSparse;
    /**
     * If *both* vectors are sparse, then we can do some additional optimization.
     *
     * @param other - The vector with which to perform an outer product
     */
    private outerProductWithSparse;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    forEach(callback: (entry: S, index: number) => void): void;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    map(valueFromEntry: (entry: S, index: number) => S): Vector<S>;
    /**
     * {@inheritDoc Vector.getDimension}
     */
    combine(other: Vector<S>, combineEntries: (a: S, b: S) => S): Vector<S>;
}

/**
 * The data stored in a {@link Vector} represented as a map
 * @public
 */
export declare type SparseVectorData<S> = ReadonlyMap<number, S>;

/**
 * Calculates the standard deviation of a vector
 * @param x - The vector
 * @public
 */
export declare function standardDeviation<S>(x: Vector<S>): S;

/**
 * Calculates the standard deviation of each column of the matrix `A`
 * @param A - The matrix
 * @public
 */
export declare function standardDeviation<S>(A: Matrix<S>): Vector<S>;

/**
 * Returns the vector `x` shifted and scaled to have a mean of 0 and standard deviation of 1
 * @param x - The vector to standardize
 * @public
 */
export declare function standardize<S>(x: Vector<S>): Vector<S>;

/**
 * Returns the matrix `A` with each column shifted and scaled to have a mean of 0 and standard deviation of 1
 * @param A - The matrix to standardize
 * @public
 */
export declare function standardize<S>(A: Matrix<S>): Matrix<S>;

/**
 * Calculates the Sum Norm (or 1-Norm) of a vector `v`
 *
 * @example
 * ```
 * const v = vec([3, 4]);
 * const norm = sumNorm(v); // 7
 * ```
 *
 * @param v - The vector for which to calculate the norm
 * @public
 */
export declare function sumNorm<S>(v: Vector<S>): number;

/**
 * A {@link Classifier} model which uses logistic regression to predict a discrete target.
 * The optimal set of parameters is computed with gradient descent.
 * @public
 */
export declare class SupportVectorMachineClassifier implements Classifier<SupportVectorMachineHyperparams> {
    private readonly _hyperParameters;
    private _weights;
    private _trainingData;
    constructor(hyperParameters: Partial<SupportVectorMachineHyperparams>);
    /**
     * Get the weights of the trained SVM, or
     * `undefined` if the model has not been trained.
     * @public
     */
    getParameters(): Vector | undefined;
    /**
     * {@inheritDoc Classifier.train}
     */
    train(data: Matrix, target: Vector): void;
    /**
     * {@inheritDoc Classifier.predictProbabilities}
     */
    predictProbabilities(_data: Matrix): Vector;
    /**
     * {@inheritDoc Classifier.predict}
     */
    predict(data: Matrix): Vector;
    /**
     * {@inheritDoc Classifier.getHyperParameters}
     */
    getHyperParameters(): SupportVectorMachineHyperparams;
    private makePredictions;
    private calculateCost;
    private calculateGradient;
    private calculateScores;
    private getDefaultHyperParameters;
}

/**
 * The set of hyperparameters for a {@link SupportVectorMachineClassifier}
 * @public
 */
export declare type SupportVectorMachineHyperparams = GradientDescentParameters & {
    /**
     * A number whose value influences the penalty for large coefficients.
     * Small values of `C` correspond to highly regularized models,
     * and correct for overfitting.
     * Large values of `C` correspond to highly biased models,
     * and correct for underfitting.
     */
    C: number;
    /**
     * A {@link Kernel} which preprocess the data and enables nonlinear decision
     * boundaries.
     */
    kernel: Kernel;
};

/**
 * Calculates the Supremum Norm (or Infinity-Norm) of a vector `v`
 *
 * @example
 * ```
 * const v = vec([3, 4]);
 * const norm = supremumNorm(v); // 4
 * ```
 *
 * @param v - The vector for which to calculate the norm
 * @public
 */
export declare function supremumNorm<S>(v: Vector<S>): number;

/**
 * Calculates the scalar triple-product of three vectors.
 * This is defined only for vectors with three dimensions.
 *
 * @param first - a vector with dimension 3
 * @param second - another vector with dimension 3
 * @param third - another vector with dimension 3
 *
 * @public
 */
export declare function tripleProduct<S>(first: Vector<S>, second: Vector<S>, third: Vector<S>): S;

declare interface UnderdeterminedSolution<S> {
    solutionType: SolutionType.UNDERDETERMINED;
    solution: Vector<S>;
}

declare interface UniqueSolution<S> {
    solutionType: SolutionType.UNIQUE;
    solution: Vector<S>;
}

/**
 * Calculates the variance of a vector
 * @param x - The vector
 * @public
 */
export declare function variance<S>(x: Vector<S>): S;

/**
 * Calculates the variance of each column of the matrix `A`
 * @param A - The matrix
 * @public
 */
export declare function variance<S>(A: Matrix<S>): Vector<S>;

/**
 * Creates a new {@link Vector} of numbers.  See {@link VectorBuilder.fromArray}
 * @public
 */
export declare function vec(data: number[]): Vector;

/**
 * A generalized Vector - one of the core data types
 * @public
 */
export declare interface Vector<S = number> {
    /**
     * Returns a {@link ScalarOperations} object which will allow consumers to work generically
     * with the scalars contained in the vector.
     * @public
     */
    ops(): ScalarOperations<S>;
    /**
     * Returns a {@link VectorBuilder} which will build new vectors of the same type
     * @public
     */
    builder(): VectorBuilder<S, Vector<S>>;
    /**
     * Returns a {@link MatrixBuilder} which will build new matrices of a compatible type
     * @public
     */
    matrixBuilder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    /**
     * Returns the contents of the vector as an array
     * @returns The contents of the vector
     * @public
     */
    toArray(): S[];
    /**
     * Returns the contents of the vector as a map of indices to nonzero values
     * @returns The contents of the vector
     * @public
     */
    getSparseData(): Map<number, S>;
    /**
     * Returns the entry of the matrix located at the provided index (`index`)
     * @param index - The index of the entry to retrieve
     * @returns The entry
     * @public
     */
    getEntry(index: number): S;
    /**
     * Returns a new vector equal to the old one, except with the entry at
     * `index` replaced with `value`
     *
     * @param index - The index of the value to replace
     * @param value - The new value
     * @returns The new vector
     * @public
     */
    set(index: number, value: S): Vector<S>;
    /**
     * Implements vector addition
     *
     * @param other - The vector to add
     * @returns The vector sum
     * @public
     */
    add(other: Vector<S>): Vector<S>;
    /**
     * Implements vector multiplication by a scalar
     *
     * @param scalar - The scalar by which to multiply
     * @returns The product
     * @public
     */
    scalarMultiply(scalar: S): Vector<S>;
    /**
     * Implements the inner product (scalar product or dot product) of two vectors
     * @param other - The vector with which to calculate an inner product
     * @returns The inner product
     * @public
     */
    innerProduct(other: Vector<S>): S;
    /**
     * Returns a new vector in the direction of `u` but with magnitude equal to the
     * amount of the original vector that lies in that direction
     * @param u - The vector on which to project this
     * @returns This vector projected onto `u`
     * @public
     */
    projectOnto(u: Vector<S>): Vector<S>;
    /**
     * Implements the outer product (matrix product) of two vectors
     * @param other - The vector with which to calculate an outer product
     * @returns The outer product
     * @public
     */
    outerProduct(other: Vector<S>): Matrix<S>;
    /**
     * Executes the `callback` function for each entry in the vector.
     * @param callback - The function to execute for each entry
     * @public
     */
    forEach(callback: (entry: S, index: number) => void): void;
    /**
     * Constructs a vector by transforming the values of another vector.
     *
     * @example
     * ```
     * const original = vectorBuilder.fromValues(1, 2, 3, 4);
     *
     * const originalPlusOne = original.map(value => value + 1);
     * // [2, 3, 4, 5]
     *
     * const originalPlusIndex = original.map((value, index) => value + index);
     * // [1, 3, 5, 7]
     * ```
     * @param valueFromEntry - A function which takes an entry of
     *     the original vector and its index, and returns the corresponding entry of the new vector
     * @returns The new vector
     * @public
     */
    map(valueFromEntry: (entry: S, index: number) => S): Vector<S>;
    /**
     * Constructs a vector by combining the values of two other vectors
     *
     * @example
     * ```
     * const first = vec([1, 2, 3]);
     * const second = vec([2, 3, 4]);
     *
     * const combined = first.combine(second, (a, b) => a * b);
     * // [2, 6, 12]
     * ```
     * @param other - The vector with which to combine this one
     * @param combineEntries - A function which takes an entry from each vector and returns a new entry
     * @returns The new vector
     * @public
     */
    combine(other: Vector<S>, combineEntries: (a: S, b: S) => S): Vector<S>;
    /**
     * Returns the dimension of the vector
     * @returns The dimension
     * @public
     */
    getDimension(): number;
    /**
     * Tests if two vectors are equal
     * @param other - The vector against which to compare
     * @returns - `true` if `this` is equal to `other`
     * @public
     */
    equals(other: Vector<S>): boolean;
}

/**
 * Provides methods for constructing {@link Vector}s of a given type
 * @public
 */
export declare class VectorBuilder<S, V extends Vector<S>> {
    private readonly _vectorConstructor;
    /**
     * @internal
     */
    constructor(vectorConstructor: VectorConstructor<S, V>);
    fromValues(...data: VectorData<S>): V;
    fromArray(data: VectorData<S>): V;
    fromNumberArray(data: VectorData<number>): V;
    fromSparseData(dimension: number, sparseData: SparseVectorData<S>): V;
    /**
     * Constructs a vector with entries given by _entry = f(i)_ where _f_ is `valueFromIndex`
     * and `i` is the index of the element
     *
     * @example
     * ```
     * vectorBuilder.fromIndexFunction(4, i => i + 3); // [ 3 4 5 6 ]
     * ```
     * @param dimension - The dimension of the vector to generate
     * @param valueFromIndex - A function returning the entry for a given index
     * @returns The new vector
     */
    fromIndexFunction(dimension: number, valueFromIndex: VectorIndexFunction<S>): V;
    /**
     * Constructs a Vector of dimension 0
     *
     * @example
     * ```
     * vectorBuilder.empty(); // []
     * ```
     *
     * @returns The new vector
     */
    empty(): V;
    /**
     * Constructs a vector whose entries are all equal to the provided value
     *
     * @example
     * ```
     * vectorBuilder.fill(3, 5); // [ 3 3 3 3 3 ]
     * ```
     *
     * @param value - The value to use as the entries of the new vector
     * @param dimension - The dimension of the new vector
     * @returns The new vector
     */
    fill(value: S, dimension: number): V;
    /**
     * Constructs a vector of all zeros
     *
     * @example
     * ```
     * vectorBuilder.zeros(3); // [ 0 0 0 ]
     * ```
     * @param dimension - The dimension of the vector to construct
     * @returns The new vector
     */
    zeros(dimension: number): V;
    /**
     * Constructs a vector of all ones
     *
     * @example
     * ```
     * vectorBuilder.ones(3); // [ 1 1 1 ]
     * ```
     * @param dimension - The dimension of the new vector
     * @returns The new vector
     */
    ones(dimension: number): V;
    /**
     * Constructs a vector that has the value 1 at one index, and 0 at the others
     *
     * @example
     * ```
     * vectorBuilder.elementaryVector(4, 2); // [ 0 0 1 0 ]
     * vectorBuilder.elementaryVector(3, 0); // [ 1 0 0 ]
     * ```
     * @param dimension - The dimension of the new vector
     * @param oneIndex - The index of the element that should be the multiplicative identity
     * @returns The new vector
     */
    elementaryVector(dimension: number, oneIndex: number): V;
    /**
     * Constructs a vector whose entries match the input vector, but offset by a given amount
     *
     * @example
     * ```
     * const original = vectorBuilder.fromArray([1, 2, 3]);
     * const rightOne = vectorBuilder.rotate(original); // [2, 3, 1];
     * const rightTwo = vectorBuilder.rotate(original, 2); // [3, 1, 2];
     * const leftOne = vectorBuilder.rotate(original, 1, true); // [3, 1, 2];
     * ```
     *
     * @param vector - The vector whose entries to use
     * @param offset - The amount by which to shift the indices
     * @param reverse - Shift entries backward rather than forward
     */
    shift(vector: Vector<S>, offset?: number, reverse?: boolean): V;
    /**
     * Constructs a vector whose entries are (uniformly-distributed) random numbers
     * between `min` and `max`
     *
     * @param dimension - The dimension of the new vector
     * @param min - The lower limit of the random numbers to include
     * @param max - The upper limit of the random numbers to include
     */
    random(dimension: number, min?: number, max?: number): V;
    /**
     * Constructs a vector whose entries are normally distributed, with the specified
     * mean and standard deviation
     *
     * @param dimension - The dimension of the new vector
     * @param mean - The center of the distribution of random numbers to include
     * @param standardDeviation - The standard deviation of the distribution of random numbers to include
     */
    randomNormal(dimension: number, mean?: number, standardDeviation?: number): V;
    /**
     * Constructs a vector consisting of two vectors end-to-end
     *
     * @example
     * ```
     * const first = vectorBuilder.ones(3);
     * const second = vectorBuilder.zeros(2);
     *
     * vectorBuilder.concatenate(first, second); // [ 1 1 1 0 0 ]
     * ```
     * @param first - The vector which will be used for the entries starting with index 0
     * @param second - The vector which will be used for the entries starting with `first.getDimension()`
     * @returns The new vector
     */
    concatenate(first: Vector<S>, second: Vector<S>): V;
    private ops;
}

/**
 * @internal
 */
export declare interface VectorConstructor<S, V extends Vector<S>> {
    new (data: VectorData<S>): V;
    ops(): ScalarOperations<S>;
    builder(): VectorBuilder<S, V>;
}

/**
 * The data stored in a {@link Vector} represented as a map
 * @public
 */
export declare type VectorData<S> = readonly S[];

/**
 * A function that generates a vector entry based on its index
 *
 * @remarks
 * This should be a pure function
 *
 * @public
 */
export declare type VectorIndexFunction<S> = (index: number) => S;

/**
 * Creates a new vector of all 0s.  See {@link VectorBuilder.zeros}
 * @public
 */
export declare function zeros(entries: number): Vector;

/**
 * Creates a new matrix of all 0s.  See {@link MatrixBuilder.zeros}
 * @public
 */
export declare function zeros(shape: MatrixShape): Matrix;

export { }
