"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../utilities/ErrorAssertions");
var RowOperations_1 = require("./RowOperations");
var Substitution_1 = require("../solvers/Substitution");
/**
 * Uses Gauss-Jordan elimination with pivoting and backward substitution
 * to solve the linear equation _Ax=b_
 *
 * @param A - The matrix _A_ in _Ax=b_
 * @param b - The vector _b_ in _Ax=b_
 * @returns The vector _x_ in _Ax=b_
 * @public
 */
function solveByGaussianElimination(A, b) {
    var augmented = A.builder().augment(A, A.builder().fromColumnVectors([b]));
    var ref = rowEchelonForm(augmented);
    return Substitution_1.backwardSubstituteAugmentedMatrix(ref);
}
exports.solveByGaussianElimination = solveByGaussianElimination;
/**
 * Uses Gauss-Jordan elimination with pivoting to calculate the inverse of a matrix.
 *
 * @remarks
 * Throws an error if the matrix is not square.
 * Returns `undefined` if the matrix is not invertible.
 *
 * @param matrix - A square matrix
 * @returns The inverse matrix
 * @public
 */
function inverse(matrix) {
    ErrorAssertions_1.assertSquare(matrix);
    var dim = matrix.getNumberOfRows();
    var I = matrix.builder().identity(dim);
    var augmented = matrix.builder().augment(matrix, I);
    var rref = reducedRowEchelonForm(augmented);
    var left = matrix.builder().slice(rref, 0, 0, dim, dim);
    var right = matrix.builder().slice(rref, 0, dim);
    if (left.equals(I)) {
        return right;
    }
    else {
        // Not invertible
        return undefined;
    }
}
exports.inverse = inverse;
/**
 * Calculates the rank of a matrix
 *
 * @remarks
 * The rank of a matrix A is the dimension of the vector space spanned by the columns of A.
 * Equivalently, it is the number of pivot entries in the row-echelon form of A, or the number
 * of nonzero rows in the row echelon form of A.
 *
 * @param matrix - the matrix for which to determine the rank
 * @public
 */
function rank(matrix) {
    var zeroRow = matrix.vectorBuilder().zeros(matrix.getNumberOfColumns());
    var ref = rowEchelonForm(matrix);
    var nonZeroRows = ref.getRowVectors().filter(function (v) { return !v.equals(zeroRow); });
    return nonZeroRows.length;
}
exports.rank = rank;
/**
 * Uses Gauss-Jordan elimination with pivoting to convert a matrix to Reduced Row-Echelon Form (RREF)
 *
 * @param matrix - The input matrix
 * @returns The matrix in RREF
 * @public
 */
function reducedRowEchelonForm(matrix) {
    var ops = matrix.ops();
    matrix = rowEchelonForm(matrix);
    var _a = matrix.getShape(), m = _a[0], n = _a[1];
    // Scale the rows
    for (var rowIndex = 0; rowIndex < m; rowIndex++) {
        var firstNonzeroEntry = undefined;
        for (var _i = 0, _b = matrix.getRow(rowIndex).toArray(); _i < _b.length; _i++) {
            var entry = _b[_i];
            if (!ops.equals(ops.zero(), entry)) {
                firstNonzeroEntry = entry;
                break;
            }
        }
        if (firstNonzeroEntry) {
            var inverse_1 = ops.getMultiplicativeInverse(firstNonzeroEntry);
            matrix = RowOperations_1.RowOperations.multiplyRowByScalar(matrix, rowIndex, inverse_1);
        }
    }
    // Clear above the pivot entries
    var maxNumberOfPivotEntries = Math.min(m, n);
    for (var pivotRow = maxNumberOfPivotEntries - 1; pivotRow >= 0; pivotRow--) {
        var pivotColumn = matrix
            .getRow(pivotRow)
            .toArray()
            .indexOf(ops.one());
        if (pivotColumn === -1) {
            continue;
        }
        matrix = clearEntriesAbove(matrix, pivotRow, pivotColumn);
    }
    return matrix;
}
exports.reducedRowEchelonForm = reducedRowEchelonForm;
/**
 * Uses Gauss-Jordan elimination with pivoting to convert a matrix to Row-Echelon Form (REF)
 *
 * @param matrix - The input matrix
 * @returns The matrix in REF
 * @public
 */
function rowEchelonForm(matrix) {
    var ops = matrix.ops();
    var maxNumberOfPivotEntries = Math.min.apply(Math, matrix.getShape());
    for (var pivotRow = 0; pivotRow < maxNumberOfPivotEntries; pivotRow++) {
        matrix = RowOperations_1.RowOperations.pivot(matrix).result;
        var pivotColumn = pivotRow;
        var pivotEntry = matrix.getEntry(pivotRow, pivotColumn);
        while (ops.equals(pivotEntry, ops.zero()) && pivotColumn < matrix.getNumberOfColumns() - 1) {
            pivotEntry = matrix.getEntry(pivotRow, ++pivotColumn);
        }
        if (ops.equals(pivotEntry, ops.zero())) {
            continue;
        }
        matrix = clearEntriesBelow(matrix, pivotRow, pivotColumn);
    }
    return matrix;
}
exports.rowEchelonForm = rowEchelonForm;
/**
 * Uses elementary row operations to clear all entries below the given pivot entry.
 * Throws an error of the necessary preconditions are not met - i.e. if the pivot
 * row is not cleared to the left.
 */
function clearEntriesBelow(matrix, pivotRow, pivotColumn) {
    checkPreconditionsForClearingBelow(matrix, pivotRow, pivotColumn);
    var ops = matrix.ops();
    var pivotEntry = matrix.getEntry(pivotRow, pivotColumn);
    for (var rowIndex = pivotRow + 1; rowIndex < matrix.getNumberOfRows(); rowIndex++) {
        var entry = matrix.getEntry(rowIndex, pivotColumn);
        if (ops.equals(entry, ops.zero())) {
            continue;
        }
        // not undefined because pivotEntry is not 0
        var coefficient = ops.divide(ops.getAdditiveInverse(entry), pivotEntry);
        matrix = RowOperations_1.RowOperations.addScalarMultipleOfRowToRow(matrix, rowIndex, pivotRow, coefficient);
    }
    return matrix;
}
/**
 * Throws an error if the row reduction algorithm prematurely attempts to
 * clear the entries below a pivot column.
 */
function checkPreconditionsForClearingBelow(matrix, pivotRow, pivotColumn) {
    var ops = matrix.ops();
    // Values to the left of the pivot should be 0
    for (var i = 0; i < pivotColumn - 1; i++) {
        if (!ops.equals(matrix.getEntry(pivotRow, i), ops.zero())) {
            throw Error('Not ready yet!');
        }
    }
}
/**
 * Uses elementary row operations to clear the entries above a pivot entry.
 * Throws an error if the necessary preconditions are not met - i.e. if the
 * pivot entry is not 1 or the pivot row is not cleared to the left and the right.
 */
function clearEntriesAbove(matrix, pivotRow, pivotColumn) {
    checkPreconditionsForClearingAbove(matrix, pivotRow, pivotColumn);
    var ops = matrix.ops();
    for (var rowIndex = pivotRow - 1; rowIndex >= 0; rowIndex--) {
        var entry = matrix.getEntry(rowIndex, pivotColumn);
        if (ops.equals(entry, ops.zero())) {
            continue;
        }
        matrix = RowOperations_1.RowOperations.addScalarMultipleOfRowToRow(matrix, rowIndex, pivotRow, ops.getAdditiveInverse(entry));
    }
    return matrix;
}
/**
 * Throws an error if the row reduction algorithm prematurely attempts to
 * clear the entries above a pivot entry.
 */
function checkPreconditionsForClearingAbove(matrix, pivotRow, pivotColumn) {
    var ops = matrix.ops();
    // Values to the left and of the pivot should be 0; the pivot should be 1
    for (var i = 0; i < pivotColumn; i++) {
        var entry = matrix.getEntry(pivotRow, i);
        if (!ops.equals(entry, ops.zero())) {
            throw Error('Not ready yet!');
        }
    }
    if (!ops.equals(matrix.getEntry(pivotRow, pivotColumn), ops.one())) {
        throw Error('Not ready yet!');
    }
}
//# sourceMappingURL=GaussJordan.js.map