"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../utilities/ErrorAssertions");
/**
 * A wrapper for static methods representing the elementary row operations
 * @public
 */
var RowOperations = /** @class */ (function () {
    function RowOperations() {
    }
    /**
     * An elementary row operations which returns a new matrix whose row
     * at `rowIndex` is multiplied by `scalar`
     *
     * @param matrix - The original matrix
     * @param rowIndex - The index of the row to modify
     * @param scalar - The factor by which to scale the row
     * @returns The matrix with the transformation applied
     * @public
     */
    RowOperations.multiplyRowByScalar = function (matrix, rowIndex, scalar) {
        ErrorAssertions_1.assertValidMatrixIndex(matrix, rowIndex, 0);
        var ops = matrix.ops();
        return RowOperations.addScalarMultipleOfRowToRow(matrix, rowIndex, rowIndex, ops.subtract(scalar, ops.one()));
    };
    /**
     * An elementary row operations which returns a new matrix whose row at `targetRow` has
     * had the row at `rowToAdd` added to it.
     *
     * @param matrix - The original matrix
     * @param targetRow - The index of the row to modify
     * @param rowToAdd - The index of the row to add
     * @returns The matrix with the transformation applied
     * @public
     */
    RowOperations.addRowToRow = function (matrix, targetRow, rowToAdd) {
        return RowOperations.addScalarMultipleOfRowToRow(matrix, targetRow, rowToAdd, matrix.ops().one());
    };
    /**
     * An elementary row operations which returns a new matrix whose row at `targetRow` has
     * had a scalar multiple of `rowToAdd` added to it.
     *
     * @param matrix - The original matrix
     * @param targetRow - The index of the row to modify
     * @param rowToAdd - The index of the row to be scaled and added
     * @param scalar - The factor by which to scale the row
     * @returns The matrix with the transformation applied
     * @public
     */
    RowOperations.addScalarMultipleOfRowToRow = function (matrix, targetRow, rowToAdd, scalar) {
        ErrorAssertions_1.assertValidMatrixIndex(matrix, targetRow, 0);
        ErrorAssertions_1.assertValidMatrixIndex(matrix, rowToAdd, 0);
        var ops = matrix.ops();
        var data = matrix.toArray();
        for (var j = 0; j < matrix.getNumberOfColumns(); j++) {
            data[targetRow][j] = ops.add(data[targetRow][j], ops.multiply(scalar, data[rowToAdd][j]));
        }
        return matrix.builder().fromArray(data);
    };
    /**
     * An elementary row operations which returns a new matrix whose row at index `first` has
     * been exchanged with the row at index `second`
     *
     * @param matrix - The original matrix
     * @param first - The index of the first row to exchange
     * @param second - The index of the second row to exchange
     * @returns The matrix with the transformation applied
     * @public
     */
    RowOperations.exchangeRows = function (matrix, first, second) {
        ErrorAssertions_1.assertValidMatrixIndex(matrix, first, 0);
        ErrorAssertions_1.assertValidMatrixIndex(matrix, second, 0);
        var dataCopy = matrix.toArray();
        var data = matrix.toArray();
        data[second] = dataCopy[first];
        data[first] = dataCopy[second];
        return matrix.builder().fromArray(data);
    };
    /**
     * Sorts the rows of a matrix according to the number of leading zeros
     * and the magnitude of the first nonzero entry
     * @public
     */
    RowOperations.pivot = function (matrix) {
        var ops = matrix.ops();
        // We will sort the rows of an identity matrix according to the number
        // of leading zeros in the corresponding row of `matrix`
        var comparator = function (iRow1, iRow2) {
            var rowIndex1 = getNumberOfLeadingZeros(iRow1);
            var rowIndex2 = getNumberOfLeadingZeros(iRow2);
            var mRow1 = matrix.getRow(rowIndex1);
            var mRow2 = matrix.getRow(rowIndex2);
            var leadingZeros1 = getNumberOfLeadingZeros(mRow1);
            var leadingZeros2 = getNumberOfLeadingZeros(mRow2);
            if (leadingZeros1 === leadingZeros2) {
                // If they have the same number of leading zeros, put
                // the entry with the greatest magnitude on top
                var firstEntry1 = mRow1.getEntry(leadingZeros1);
                var firstEntry2 = mRow2.getEntry(leadingZeros2);
                return ops.norm(firstEntry2) - ops.norm(firstEntry1);
            }
            return leadingZeros1 - leadingZeros2;
        };
        var I = matrix.builder().identity(matrix.getNumberOfRows());
        var P = matrix.builder().fromRowVectors(I.getRowVectors().sort(comparator));
        var permuted = P.multiply(matrix);
        return {
            operator: P,
            result: permuted
        };
    };
    return RowOperations;
}());
exports.RowOperations = RowOperations;
function getNumberOfLeadingZeros(v) {
    var ops = v.ops();
    var zeros = 0;
    for (var _i = 0, _a = v.toArray(); _i < _a.length; _i++) {
        var item = _a[_i];
        if (ops.equals(item, ops.zero())) {
            ++zeros;
        }
        else {
            break;
        }
    }
    return zeros;
}
//# sourceMappingURL=RowOperations.js.map