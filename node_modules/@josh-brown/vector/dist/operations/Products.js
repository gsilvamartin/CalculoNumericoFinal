"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Computes the dot/inner/scalar product of two vectors.  See {@link Vector.innerProduct}.
 *
 * @param first - the left vector in the product
 * @param second - the right vector in the product
 *
 * @public
 */
function dotProduct(first, second) {
    return first.innerProduct(second);
}
exports.dotProduct = dotProduct;
function hadamardProduct(first, second) {
    var ops = first.ops();
    // TODO: The type assertion below is not correct, but it satisfies tsc.
    return first.combine(second, function (x, y) { return ops.multiply(x, y); });
}
exports.hadamardProduct = hadamardProduct;
/**
 * Computes the Kronecker product (generalized outer product) of two matrices.
 *
 * @param first - the left matrix in the product
 * @param second - the right matrix in the product
 *
 * @public
 */
function kroneckerProduct(first, second) {
    var block = [];
    first.getColumnVectors().forEach(function (columnOfFirst, i) {
        second.getRowVectors().forEach(function (rowOfSecond, j) {
            block[i] = block[i] || [];
            block[i][j] = columnOfFirst.outerProduct(rowOfSecond);
        });
    });
    return first.builder().block(block);
}
exports.kroneckerProduct = kroneckerProduct;
/**
 * Calculates the cross-product (vector-product) of two vectors.
 * This is defined only for vectors with three dimensions.
 *
 * @param first - a vector with dimension 3
 * @param second - another vector with dimension 3
 *
 * @public
 */
function crossProduct(first, second) {
    if (first.getDimension() !== 3 || second.getDimension() !== 3) {
        throw new Error('The cross product is only defined for vectors of dimension 3');
    }
    var ops = first.ops();
    var _a = first.toArray(), x1 = _a[0], y1 = _a[1], z1 = _a[2];
    var _b = second.toArray(), x2 = _b[0], y2 = _b[1], z2 = _b[2];
    var x = ops.add(ops.multiply(y1, z2), ops.multiply(ops.negativeOne(), ops.multiply(z1, y2)));
    var y = ops.add(ops.multiply(z1, x2), ops.multiply(ops.negativeOne(), ops.multiply(x1, z2)));
    var z = ops.add(ops.multiply(x1, y2), ops.multiply(ops.negativeOne(), ops.multiply(y1, x2)));
    return first.builder().fromValues(x, y, z);
}
exports.crossProduct = crossProduct;
/**
 * Calculates the scalar triple-product of three vectors.
 * This is defined only for vectors with three dimensions.
 *
 * @param first - a vector with dimension 3
 * @param second - another vector with dimension 3
 * @param third - another vector with dimension 3
 *
 * @public
 */
function tripleProduct(first, second, third) {
    if (first.getDimension() !== 3 || second.getDimension() !== 3 || third.getDimension() !== 3) {
        throw new Error('The triple product is only defined for vectors of dimension 3');
    }
    return first.innerProduct(crossProduct(second, third));
}
exports.tripleProduct = tripleProduct;
//# sourceMappingURL=Products.js.map