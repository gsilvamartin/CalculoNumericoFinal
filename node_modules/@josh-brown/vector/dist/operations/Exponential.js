"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../utilities/ErrorAssertions");
var NumberUtilities_1 = require("../utilities/NumberUtilities");
var GaussJordan_1 = require("./GaussJordan");
var Norms_1 = require("./Norms");
/**
 * Computes _A^n_ recursively.
 *
 * @param A - The matrix to raise to a power `n`
 * @param n - The power to which to raise `A`
 * @public
 */
function pow(A, n) {
    // TODO - memoize these results
    if (n < 0) {
        var invA = GaussJordan_1.inverse(A);
        if (invA === undefined) {
            throw Error('Cannot raise a non-invertible matrix to a negative power');
        }
        return pow(invA, -n);
    }
    if (n === 0) {
        return A.builder().identity(A.getNumberOfColumns());
    }
    return A.multiply(pow(A, n - 1));
}
exports.pow = pow;
/**
 * Implements the Pade Approximant to compute the exponential of matrix `A`
 *
 * @param A - The matrix to exponentiate
 * @param order - The order of the approximation - higher numbers yield more accurate results
 * @public
 */
function exp(A, order) {
    if (order === void 0) { order = 6; }
    ErrorAssertions_1.assertSquare(A);
    var ops = A.ops();
    // To increase numerical stability, choose a scale factor m that
    // leaves the norm of A/m inside a reasonable bound.
    // To reduce the number of matrix multiplications when computing the
    // final result, choose m = 2^k so we can scale back at the end by
    // repeatedly squaring.
    var k = getScaleFactorExponent(A);
    var m = Math.pow(2, k);
    var scaleFactor = ops.fromNumber(1 / m);
    // Scale A downward, and perform the approximation on A/m
    var scaledA = A.scalarMultiply(scaleFactor);
    // R is an approximation for exp(scaledA)
    var R = computeR(scaledA, order, order);
    // Scale back up to get exp(A)
    var expA = deScaleSolution(R, k);
    return expA;
}
exports.exp = exp;
/**
 * Returns the smallest integral exponent k such that A/(2^k) has a 1-norm less than 0.5
 *
 * @param A - The matrix to scale down
 */
function getScaleFactorExponent(A) {
    var norm = Norms_1.columnSumSupremumNorm(A);
    var scaledNorm = norm;
    var exponent = 0;
    while (scaledNorm > 0.5) {
        exponent++;
        scaledNorm /= 2;
    }
    return exponent;
}
/**
 * Returns exp(A) given exp(A/(2^k)) by repeatedly squaring the latter.
 * Note: _exp(A) = exp(A/(2^k))^(2^k)_
 *
 * @param exponentialOfScaledMatrix - The calculated exponential of original matrix `A` scaled down
 * @param scaleFactorExponent  - The exponent `k` that was used to scale down the original matrix `A`
 */
function deScaleSolution(exponentialOfScaledMatrix, scaleFactorExponent) {
    var exponentialOfOriginalMatrix = exponentialOfScaledMatrix;
    for (var i = 0; i < scaleFactorExponent; i++) {
        exponentialOfOriginalMatrix = exponentialOfOriginalMatrix.multiply(exponentialOfOriginalMatrix);
    }
    return exponentialOfOriginalMatrix;
}
/**
 * Computes the (p,q) Pade approximation for the exponential of matrix `A` - a rational
 * function that converges more quickly than the power series definition of the matrix exponential
 *
 * @param A - The matrix `A` to exponentiate
 * @param p - The number of terms in the numerator of the rational function
 * @param q - The number of terms in the denominator of the rational function
 */
function computeR(A, p, q) {
    var N = computeN(A, p, q);
    var D = computeD(A.scalarMultiply(A.ops().negativeOne()), p, q);
    var dInverse = GaussJordan_1.inverse(D);
    if (dInverse === undefined) {
        throw Error('Encountered an unexpected non-invertible matrix in the exponential calculation');
    }
    return dInverse.multiply(N);
}
/**
 * Computes the matrix which gives the numerator of the rational function approximation
 *
 * @param A - The matrix `A` to exponentiate
 * @param p - The number of terms in the numerator of the rational function
 * @param q - The number of terms in the denominator of the rational function
 */
function computeN(A, p, q) {
    var n = A.getNumberOfColumns();
    var result = A.builder().zeros([n, n]);
    for (var j = 0; j < p; j++) {
        result = result.add(computeJthTermOfN(A, p, q, j));
    }
    return result;
}
/**
 * Computes the jth term of the numerator matrix `N`
 *
 * @param A - The matrix `A` to exponentiate
 * @param p - The number of terms in the numerator of the rational function
 * @param q - The number of terms in the denominator of the rational function
 * @param j - The index of the term being computed
 */
function computeJthTermOfN(A, p, q, j) {
    var ops = A.ops();
    var numerator = ops.fromNumber(NumberUtilities_1.factorial(p + q - j) * NumberUtilities_1.factorial(p));
    var denominator = ops.fromNumber(NumberUtilities_1.factorial(p + q) * NumberUtilities_1.factorial(j) * NumberUtilities_1.factorial(p - j));
    var coefficient = ops.divide(numerator, denominator); // can never be 0
    return pow(A, j).scalarMultiply(coefficient);
}
/**
 * Computes the matrix which gives the denominator of the rational function approximation
 *
 * @param negativeA - The additive inverse of the matrix being exponentiated
 * @param p - The number of terms in the numerator of the rational function
 * @param q - The number of terms in the denominator of the rational function
 */
function computeD(negativeA, p, q) {
    var n = negativeA.getNumberOfColumns();
    var result = negativeA.builder().zeros([n, n]);
    for (var j = 0; j < q; j++) {
        result = result.add(computeJthTermOfD(negativeA, p, q, j));
    }
    return result;
}
/**
 * Computes the jth term of the denominator matrix `D`
 *
 * @param negativeA - The additive inverse of the matrix being exponentiated
 * @param p - The number of terms in the numerator of the rational function
 * @param q - The number of terms in the denominator of the rational function
 * @param j - The index of the term being computed
 */
function computeJthTermOfD(negativeA, p, q, j) {
    var ops = negativeA.ops();
    var numerator = ops.fromNumber(NumberUtilities_1.factorial(p + q - j) * NumberUtilities_1.factorial(q));
    var denominator = ops.fromNumber(NumberUtilities_1.factorial(p + q) * NumberUtilities_1.factorial(j) * NumberUtilities_1.factorial(q - j));
    var coefficient = ops.divide(numerator, denominator); // can never be 0
    return pow(negativeA, j).scalarMultiply(coefficient);
}
//# sourceMappingURL=Exponential.js.map