"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Norms_1 = require("../../../operations/Norms");
var DescriptiveStatistics_1 = require("../../statistics/DescriptiveStatistics");
function kMeansClustering(X, params) {
    var rows = X.getRowVectors();
    var _a = X.getShape(), m = _a[0], n = _a[1];
    var _b = params.k, k = _b === void 0 ? 5 : _b, _c = params.norm, norm = _c === void 0 ? Norms_1.euclideanNorm : _c, _d = params.maxIterations, maxIterations = _d === void 0 ? 100 : _d;
    var centroids = initializeCentroids(X, k, n);
    var labels = X.vectorBuilder().zeros(m);
    var iter = 0;
    while (iter < maxIterations) {
        var nextLabels = updateLabels(rows, centroids, norm);
        var changed = !nextLabels.equals(labels);
        labels = nextLabels;
        centroids = updateCentroids(rows, labels);
        if (!changed)
            break;
        iter++;
    }
    return { centroids: centroids, labels: labels };
}
exports.kMeansClustering = kMeansClustering;
function updateLabels(rows, centroids, norm) {
    var m = rows.length;
    var vectorBuilder = rows[0].builder();
    return vectorBuilder.fromIndexFunction(m, function (i) {
        return getIndexOfClosestCentroid(rows[i], centroids, norm);
    });
}
function getIndexOfClosestCentroid(row, centroids, norm) {
    var min = Number.MAX_VALUE;
    var index = -1;
    centroids.forEach(function (centroid, i) {
        var distance = norm(row.scalarMultiply(-1).add(centroid));
        if (distance < min) {
            min = distance;
            index = i;
        }
    });
    return index;
}
function updateCentroids(rows, labels) {
    var n = rows[0].getDimension();
    var zero = rows[0].builder().zeros(n);
    var clusters = [];
    rows.forEach(function (row, i) {
        var label = labels.getEntry(i);
        clusters[label] = clusters[label] || [];
        clusters[label].push(row);
    });
    var centroids = clusters.map(function (cluster) {
        if (!cluster || !cluster.length) {
            throw new Error('TODO: re-initialize');
        }
        var clusterSize = cluster.length;
        var sum = cluster.reduce(function (curr, next) { return curr.add(next); }, zero);
        return sum.scalarMultiply(1 / clusterSize);
    });
    return centroids;
}
function initializeCentroids(X, k, n) {
    var vectorBuilder = X.vectorBuilder();
    var ops = X.ops();
    ops.randomNormal;
    var means = DescriptiveStatistics_1.mean(X);
    var stdDevs = DescriptiveStatistics_1.standardDeviation(X).map(function (x) { return 2 * x; });
    var cols = [];
    for (var i = 0; i < n; i++) {
        cols.push(vectorBuilder.randomNormal(k, means.getEntry(i), stdDevs.getEntry(i)));
    }
    return X.builder()
        .fromColumnVectors(cols)
        .getRowVectors();
}
//# sourceMappingURL=kMeansClustering.js.map