"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var FloatVector_1 = require("../../../types/vector/FloatVector");
var LinearKernel_1 = require("../kernels/LinearKernel");
var GradientDescent_1 = require("../GradientDescent");
/**
 * A {@link Classifier} model which uses logistic regression to predict a discrete target.
 * The optimal set of parameters is computed with gradient descent.
 * @public
 */
var SupportVectorMachineClassifier = /** @class */ (function () {
    function SupportVectorMachineClassifier(hyperParameters) {
        this._hyperParameters = Object.freeze(hyperParameters);
    }
    /**
     * Get the weights of the trained SVM, or
     * `undefined` if the model has not been trained.
     * @public
     */
    SupportVectorMachineClassifier.prototype.getParameters = function () {
        return this._weights;
    };
    /**
     * {@inheritDoc Classifier.train}
     */
    SupportVectorMachineClassifier.prototype.train = function (data, target) {
        var _this = this;
        var kernel = this.getHyperParameters().kernel;
        this._trainingData = data;
        var X = kernel(data, this._trainingData);
        var initialWeights = FloatVector_1.FloatVector.builder().random(X.getNumberOfColumns(), -0.01, 0.01);
        this._weights = GradientDescent_1.gradientDescent(this._hyperParameters)(initialWeights, function (weights) { return ({
            cost: _this.calculateCost(X, target, weights),
            gradient: _this.calculateGradient(X, target, weights)
        }); });
    };
    /**
     * {@inheritDoc Classifier.predictProbabilities}
     */
    SupportVectorMachineClassifier.prototype.predictProbabilities = function (_data) {
        throw Error("Probability predictions not implemented for SVM Classifier");
    };
    /**
     * {@inheritDoc Classifier.predict}
     */
    SupportVectorMachineClassifier.prototype.predict = function (data) {
        if (!this._weights)
            throw new Error("Cannot call predict before train");
        var kernel = this.getHyperParameters().kernel;
        var X = kernel(data, this._trainingData);
        return this.makePredictions(X, this._weights);
    };
    /**
     * {@inheritDoc Classifier.getHyperParameters}
     */
    SupportVectorMachineClassifier.prototype.getHyperParameters = function () {
        return __assign(__assign({}, this.getDefaultHyperParameters()), this._hyperParameters);
    };
    SupportVectorMachineClassifier.prototype.makePredictions = function (X, weights) {
        var scores = this.calculateScores(X, weights);
        return scores.map(function (score) { return (score > 0 ? 1 : 0); });
    };
    SupportVectorMachineClassifier.prototype.calculateCost = function (X, target, weights) {
        var m = X.getShape()[0];
        var scores = this.calculateScores(X, weights);
        var costs = scores.map(function (score, i) {
            return cost(score, target.getEntry(i));
        });
        var totalCost = costs.toArray().reduce(function (prev, curr) { return prev + curr; }, 0);
        return totalCost / m;
    };
    SupportVectorMachineClassifier.prototype.calculateGradient = function (X, target, weights) {
        var m = X.getShape()[0];
        var scores = this.calculateScores(X, weights);
        // 0 indicates 0-cost; we exceed the margin on the correct side
        // 1 indicates a negative example which fails the margin condition
        // -1 indicates a positive example fails the margin condition
        //
        // TODO: This can be solved a lot more elegantly with a generic rather than
        // binary classifier.  This would allow us to have only 0 or 1 instead of this mess.
        var failsMarginCondition = scores.builder().fromArray(scores.toArray().map(function (score, i) {
            var y = target.getEntry(i);
            var rowCost = cost(score, target.getEntry(i));
            if (rowCost === 0)
                return 0;
            return y === 0 ? 1 : -1;
        }));
        var unscaledGradient = X.transpose().apply(failsMarginCondition);
        return unscaledGradient.scalarMultiply(1 / m);
    };
    SupportVectorMachineClassifier.prototype.calculateScores = function (X, weights) {
        return X.apply(weights);
    };
    SupportVectorMachineClassifier.prototype.getDefaultHyperParameters = function () {
        return {
            C: 0,
            kernel: LinearKernel_1.LinearKernel,
            alpha: 0.01
        };
    };
    return SupportVectorMachineClassifier;
}());
exports.SupportVectorMachineClassifier = SupportVectorMachineClassifier;
function cost(score, y) {
    if (y > 0.5) {
        // y = 1
        return cost1(score);
    }
    else {
        return cost0(score);
    }
}
function cost0(score) {
    if (score < -1) {
        // Decision is very correct
        return 0;
    }
    else {
        return 1 + score;
    }
}
function cost1(score) {
    if (score > 1) {
        // Decision is very correct
        return 0;
    }
    else {
        return 1 - score;
    }
}
//# sourceMappingURL=SupportVectorMachineClassifier.js.map