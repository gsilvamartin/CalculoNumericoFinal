"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var NumberUtilities_1 = require("../../../utilities/NumberUtilities");
var GradientDescent_1 = require("../GradientDescent");
var FloatVector_1 = require("../../../types/vector/FloatVector");
var LinearKernel_1 = require("../kernels/LinearKernel");
/**
 * A {@link Classifier} model which uses logistic regression to predict a discrete target.
 * The optimal set of parameters is computed with gradient descent.
 * @public
 */
var LogisticRegressionClassifier = /** @class */ (function () {
    function LogisticRegressionClassifier(hyperParameters) {
        this._hyperParameters = Object.freeze(hyperParameters);
    }
    /**
     * Get the coefficients of the trained linear regression model, or
     * `undefined` if the model has not been trained.
     * @public
     */
    LogisticRegressionClassifier.prototype.getParameters = function () {
        return this._theta;
    };
    /**
     * {@inheritDoc Classifier.getHyperParameters}
     */
    LogisticRegressionClassifier.prototype.getHyperParameters = function () {
        return __assign(__assign({}, this.getDefaultHyperParameters()), this._hyperParameters);
    };
    /**
     * {@inheritDoc Classifier.train}
     */
    LogisticRegressionClassifier.prototype.train = function (data, target) {
        var _this = this;
        var initialTheta = FloatVector_1.FloatVector.builder().random(data.getNumberOfColumns() + 1, -0.01, 0.01);
        this._theta = GradientDescent_1.gradientDescent(this._hyperParameters)(initialTheta, function (theta) { return ({
            cost: _this.calculateCost(data, target, theta),
            gradient: _this.calculateGradient(data, target, theta)
        }); });
    };
    /**
     * {@inheritDoc Classifier.predictProbabilities}
     */
    LogisticRegressionClassifier.prototype.predictProbabilities = function (data) {
        if (!this._theta)
            throw new Error("Cannot call predictProbabilities before train");
        return this.makeProbabilityPredictions(data, this._theta);
    };
    /**
     * {@inheritDoc Classifier.predict}
     */
    LogisticRegressionClassifier.prototype.predict = function (data) {
        if (!this._theta)
            throw new Error("Cannot call predict before train");
        return this.makePredictions(data, this._theta);
    };
    LogisticRegressionClassifier.prototype.makePredictions = function (data, theta, threshold) {
        return this.makeProbabilityPredictions(data, theta).map(function (p) { return (p > (threshold || 0.5) ? 1 : 0); });
    };
    LogisticRegressionClassifier.prototype.makeProbabilityPredictions = function (data, theta) {
        return LinearKernel_1.LinearKernel(data)
            .apply(theta)
            .map(NumberUtilities_1.sigmoid);
    };
    LogisticRegressionClassifier.prototype.calculateCost = function (data, target, theta) {
        var lambda = this.getHyperParameters().lambda;
        var probabilities = this.makeProbabilityPredictions(data, theta);
        var costs = probabilities.map(function (pred, i) {
            var actual = target.getEntry(i);
            if (actual > 0.5) {
                // Event; actual === 1
                return -1 * Math.log(pred);
            }
            else {
                // Nonevent; actual === 0
                return -1 * Math.log(1 - pred);
            }
        });
        var meanCost = costs.toArray().reduce(function (prev, curr) { return prev + curr; }, 0) / data.getNumberOfRows();
        var penalty = function (x) { return x * x; };
        var paramSum = theta.toArray().reduce(function (prev, curr) { return penalty(prev) + curr; }, 0);
        var regularizationTerm = paramSum - penalty(theta.getEntry(0));
        return meanCost + lambda * regularizationTerm;
    };
    /**
     * {@inheritDoc GradientDescentClassifier.calculateGradient}
     */
    LogisticRegressionClassifier.prototype.calculateGradient = function (data, target, theta) {
        var m = data.getNumberOfRows();
        var lambda = this.getHyperParameters().lambda;
        var predictions = this.makeProbabilityPredictions(data, theta);
        var diff = predictions.add(target.scalarMultiply(-1));
        var gradientTerm = LinearKernel_1.LinearKernel(data)
            .transpose()
            .apply(diff)
            .scalarMultiply(1 / m);
        var regularizationTerm = theta.scalarMultiply(lambda / m).set(0, 0);
        return gradientTerm.add(regularizationTerm);
    };
    LogisticRegressionClassifier.prototype.getDefaultHyperParameters = function () {
        return {
            lambda: 0,
            alpha: 0.01
        };
    };
    return LogisticRegressionClassifier;
}());
exports.LogisticRegressionClassifier = LogisticRegressionClassifier;
//# sourceMappingURL=LogisticRegressionClassifier.js.map