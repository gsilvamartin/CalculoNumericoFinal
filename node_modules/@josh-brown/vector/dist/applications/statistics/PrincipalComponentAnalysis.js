"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DescriptiveStatistics_1 = require("./DescriptiveStatistics");
var Eigenvalues_1 = require("../../eigenvalues/Eigenvalues");
/**
 * Conducts a principal component analysis of a matrix `A`, and returns `A` in a new basis
 * corresponding to the principal components.
 * @param A - The matrix to analyze
 * @param useCorrelation - Whether to use correlation rather than covariance to determine
 *     principal components.  Equivalently, whether to standardize rather than merely center
 *     the data.  This option should be used if the variables in the data naturally fall on
 *     different scales.
 * @public
 */
function pca(A, useCorrelation) {
    if (useCorrelation === void 0) { useCorrelation = false; }
    var ops = A.ops();
    var C = useCorrelation ? DescriptiveStatistics_1.correlation(A) : DescriptiveStatistics_1.covariance(A);
    var pairs = Eigenvalues_1.eig(C);
    // The eigenvectors of the covariance matrix are the principal components of the data
    var principalComponents = pairs.map(function (pair) { return pair.eigenvector; });
    // The eigenvalues of the covariance matrix are the variances of the principal components
    var variances = pairs.map(function (pair) { return pair.eigenvalue; });
    // Reframe the data in the new basis
    var coordinates = A.multiply(A.builder().fromColumnVectors(principalComponents));
    // Sum the eigenvalues
    var totalVariance = useCorrelation
        ? ops.fromNumber(variances.length)
        : variances.reduce(function (total, next) { return ops.add(total, next); }, ops.zero());
    // The proportion of the total variance explained by each variable
    var proportions = variances.map(function (variance) { return ops.divide(variance, totalVariance); });
    // The proportion of the total variance explained by the first k variables
    var cumulativeProportions = [];
    proportions.forEach(function (prop) {
        var currentTotal = cumulativeProportions.length === 0
            ? ops.zero()
            : cumulativeProportions[cumulativeProportions.length - 1];
        cumulativeProportions.push(ops.add(currentTotal, prop));
    });
    return { variances: variances, proportions: proportions, cumulativeProportions: cumulativeProportions, principalComponents: principalComponents, coordinates: coordinates };
}
exports.pca = pca;
/**
 * Reduce the number of dimensions of a data matrix `A` while losing as little information as possible.
 * @param A - The data matrix
 * @param options - Specify how the dimension reduction should be done.
 *     `useCorrelation: boolean` - use the correlation rather than covariance matrix when conducting the PCA;
 *     `keep: number` - the desired number of dimensions;
 *     `remove: number` - the number of dimensions to remove;
 *     `proportionOfVariance: number` - the desired proportion of the total variance in the data that should
 *          be explained by the remaining columns
 * @public
 */
function reduceDimensions(A, options) {
    var keep = A.getNumberOfColumns();
    if (hasKeep(options) && (options.keep > keep || options.keep < 0)) {
        throw Error("Cannot keep " + options.keep + " dimensions of a matrix with " + keep + " columns");
    }
    else if (hasRemove(options) && (options.remove > keep || options.remove < 0)) {
        throw Error("Cannot remove " + options.remove + " dimensions of a matrix with " + keep + " columns");
    }
    else if (hasPropVar(options) &&
        (options.proportionOfVariance < 0 || options.proportionOfVariance > 1)) {
        throw Error(options.proportionOfVariance + " is not a valid proportion - expected between 0 and 1");
    }
    var analysis = pca(A, options.useCorrelation || false);
    if (hasKeep(options)) {
        keep = options.keep;
    }
    else if (hasRemove(options)) {
        keep = A.getNumberOfColumns() - options.remove;
    }
    else if (hasPropVar(options)) {
        for (var _i = 0, _a = analysis.cumulativeProportions; _i < _a.length; _i++) {
            var prop = _a[_i];
            // TODO - it is currently this line that keeps this from working on general
            // scalar types. Even though the eigenvalues are definitely real in this
            // case, we still can't coerce them to numbers. Maybe pca should return
            // numbers for the proportions?
            if (prop > options.proportionOfVariance) {
                keep = analysis.cumulativeProportions.indexOf(prop) + 1;
                break;
            }
        }
    }
    return A.builder().slice(analysis.coordinates, 0, 0, A.getNumberOfRows(), keep);
}
exports.reduceDimensions = reduceDimensions;
function hasKeep(options) {
    return options.keep;
}
function hasRemove(options) {
    return options.remove;
}
function hasPropVar(options) {
    return options.proportionOfVariance;
}
//# sourceMappingURL=PrincipalComponentAnalysis.js.map