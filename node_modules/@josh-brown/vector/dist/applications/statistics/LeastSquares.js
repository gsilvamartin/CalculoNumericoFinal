"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../../utilities/ErrorAssertions");
var GaussJordan_1 = require("../../operations/GaussJordan");
var LinearSolution_1 = require("../../solvers/LinearSolution");
/**
 * Calculates a linear regression model for the provided `dataPoints`.
 *
 * @remarks
 * The result is an object which has:
 * - `coefficients`: a vector whose first entry is the constant term, and whose
 *     following entries are the coefficients for the other independent variables, in
 *     the same order they appear in the `dataPoints`
 * - `approximationFunction`: a function which takes a vector of the independent variable
 *     values, and returns the predicted value of the dependent variable
 *
 * @param dataPoints - An array of vectors, each of which
 *    represents a single data point where the last entry is the variable to be predicted,
 *    and the other entries are the values of the independent variables
 * @returns - the result of the linear regression
 * @public
 */
function calculateLinearLeastSquares(dataPoints) {
    ErrorAssertions_1.assertNonEmpty(dataPoints);
    ErrorAssertions_1.assertHomogeneous(dataPoints);
    var ops = dataPoints[0].ops();
    var numberOfIndependentVariables = dataPoints[0].getDimension() - 1;
    var linearFunctionTemplate = function (coefficients) {
        return function (input) {
            var value = coefficients.getEntry(0); // constant term
            for (var i = 1; i < coefficients.getDimension(); i++) {
                var newTerm = ops.multiply(coefficients.getEntry(i), input.getEntry(i - 1));
                value = ops.add(value, newTerm);
            }
            return value;
        };
    };
    return calculateGeneralLeastSquares(dataPoints, linearFunctionTemplate, numberOfIndependentVariables + 1);
}
exports.calculateLinearLeastSquares = calculateLinearLeastSquares;
/**
 * Calculates a regression model for an arbitrary function.
 *
 * @remarks
 * The result is on object which has:
 * - `coefficients`: a vector whose entries correspond to the coefficients which must
 *     be plugged into the function template to yield the best approximation function
 * - `approximationFunction`: a function which takes a vector of the independent variable
 *     values, and returns the predicted value of the dependent variable
 *
 * @param dataPoints - The data used to construct the approximation
 * @param functionTemplate - A higher-order
 *     function which takes a vector of coefficients and yields a new function which takes
 *     a vector of independent variables to produce a value for the dependent variable
 * @param numberOfTerms - The number of coefficients needed to produce
 *     the approximation function
 * @returns - the result of the linear regression
 * @public
 */
function calculateGeneralLeastSquares(dataPoints, functionTemplate, numberOfTerms) {
    ErrorAssertions_1.assertNonEmpty(dataPoints);
    ErrorAssertions_1.assertHomogeneous(dataPoints);
    var matrixBuilder = dataPoints[0].matrixBuilder();
    var vectorBuilder = dataPoints[0].builder();
    var numberOfIndependentVariables = dataPoints[0].getDimension() - 1;
    var numberOfDataPoints = dataPoints.length;
    var getEntryInA = function (dataPointIndex, coefficientIndex) {
        // Use the output value that would occur at this data point if this
        // were the only nonzero coefficient and it were one
        var elementaryCoefficients = vectorBuilder.elementaryVector(numberOfTerms, coefficientIndex);
        var inputs = dataPoints[dataPointIndex];
        var hypotheticalApproximationFunction = functionTemplate(elementaryCoefficients);
        return hypotheticalApproximationFunction(inputs);
    };
    var getEntryInOutputVector = function (index) {
        return dataPoints[index].getEntry(numberOfIndependentVariables); // last entry
    };
    var A = matrixBuilder.fromIndexFunction([numberOfDataPoints, numberOfTerms], getEntryInA);
    var outputVector = vectorBuilder.fromIndexFunction(numberOfDataPoints, getEntryInOutputVector);
    var coefficients = solveOverdeterminedSystem(A, outputVector);
    var approximationFunction = functionTemplate(coefficients);
    return { coefficients: coefficients, approximationFunction: approximationFunction };
}
exports.calculateGeneralLeastSquares = calculateGeneralLeastSquares;
/**
 * Gives an approximate solution to an overdetermined linear system.
 *
 * @remarks
 * When the system _Ax = b_ is overdetermined, it has no solution.
 * However, there exists a unique vector _x_ which minimizes the  difference Ax-b,
 * which solves `A.transpose().multiply(A).apply(x) === A.transpose().apply(b)`
 *
 * @param A - The matrix _A_ in _Ax = b_
 * @param b - The vector _b_ in _Ax = b_
 * @public
 */
function solveOverdeterminedSystem(A, b) {
    checkDimensionsForOverdeterminedSystem(A, b);
    var aTrans = A.adjoint();
    var aTransB = aTrans.apply(b);
    var aTransA = aTrans.multiply(A);
    var leastSquaresSolution = GaussJordan_1.solveByGaussianElimination(aTransA, aTransB);
    if (leastSquaresSolution.solutionType === LinearSolution_1.SolutionType.UNIQUE) {
        return leastSquaresSolution.solution;
    }
    else if (leastSquaresSolution.solutionType === LinearSolution_1.SolutionType.UNDERDETERMINED) {
        return leastSquaresSolution.solution;
    }
    else {
        throw Error('Unexpectedly encountered overdetermined system');
    }
}
exports.solveOverdeterminedSystem = solveOverdeterminedSystem;
function checkDimensionsForOverdeterminedSystem(A, b) {
    if (A.getNumberOfRows() !== b.getDimension()) {
        throw new Error('Dimension mismatch');
    }
}
//# sourceMappingURL=LeastSquares.js.map