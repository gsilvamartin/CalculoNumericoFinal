"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var typeGuards_1 = require("../../utilities/typeGuards");
function mean(xOrA) {
    if (typeGuards_1.isVector(xOrA)) {
        var x = xOrA;
        var ops = x.ops();
        var dimInverse = ops.getMultiplicativeInverse(ops.fromNumber(x.getDimension()));
        if (dimInverse === undefined)
            throw Error('The mean is not defined for vectors of length 0');
        var ones = x.builder().ones(x.getDimension());
        return ones.scalarMultiply(dimInverse).innerProduct(x);
    }
    else {
        return xOrA.vectorBuilder().fromArray(xOrA.getColumnVectors().map(function (v) { return mean(v); }));
    }
}
exports.mean = mean;
function center(xOrA) {
    if (typeGuards_1.isVector(xOrA)) {
        var x = xOrA;
        if (x.getDimension() === 0)
            return x;
        var mu = x.builder().fill(mean(x), x.getDimension());
        return x.add(mu.scalarMultiply(x.ops().negativeOne()));
    }
    else {
        var A = xOrA;
        if (A.getNumberOfColumns() === 0)
            return A;
        var ops = A.ops();
        var rows = A.getNumberOfRows();
        var dim = ops.fromNumber(rows);
        var dimInverse = ops.getMultiplicativeInverse(dim);
        var offsets = A.builder()
            .fill(dimInverse, [rows, rows])
            .multiply(A);
        return A.add(offsets.scalarMultiply(ops.negativeOne()));
    }
}
exports.center = center;
function standardize(xOrA) {
    if (typeGuards_1.isVector(xOrA)) {
        if (xOrA.getDimension() === 0)
            return xOrA;
        var ops = xOrA.ops();
        var centered = center(xOrA);
        var std = standardDeviation(xOrA);
        var stdInverse = ops.getMultiplicativeInverse(std);
        if (stdInverse === undefined) {
            // Standard deviation is 0; just return the centered vector
            return centered;
        }
        return centered.scalarMultiply(stdInverse);
    }
    else {
        if (xOrA.getNumberOfColumns() === 0)
            return xOrA;
        return xOrA.builder().fromColumnVectors(xOrA.getColumnVectors().map(function (v) { return standardize(v); }));
    }
}
exports.standardize = standardize;
function variance(xOrA) {
    if (typeGuards_1.isVector(xOrA)) {
        if (xOrA.getDimension() === 0)
            throw Error('Variance is not defined for vectors of length 0');
        return covariance(xOrA, xOrA);
    }
    else {
        return xOrA.vectorBuilder().fromArray(xOrA.getColumnVectors().map(function (v) { return variance(v); }));
    }
}
exports.variance = variance;
function standardDeviation(xOrA) {
    if (typeGuards_1.isVector(xOrA)) {
        if (xOrA.getDimension() === 0)
            throw Error('Standard deviation is not defined for 0-dimensional vectors');
        return xOrA.ops().getPrincipalSquareRoot(variance(xOrA));
    }
    else {
        return xOrA.vectorBuilder().fromArray(xOrA.getColumnVectors().map(function (v) { return standardDeviation(v); }));
    }
}
exports.standardDeviation = standardDeviation;
function covariance(xOrA, s) {
    if (typeGuards_1.isVector(xOrA)) {
        var first = xOrA;
        var second = s;
        var ops = first.ops();
        var dim = first.getDimension();
        if (dim === 0)
            throw Error('Covariance is not defined for vectors of dimension 0');
        if (second.getDimension() !== dim)
            throw Error('Covariance is not defined for vectors of different lengths');
        var ip = center(first).innerProduct(center(second));
        return ops.divide(ip, ops.fromNumber(dim));
    }
    else {
        var A = xOrA;
        var ops = A.ops();
        var rows = A.getNumberOfRows();
        var dim = ops.fromNumber(rows);
        var dimInverse = ops.getMultiplicativeInverse(dim);
        if (dimInverse === undefined)
            throw Error('The covariance matrix is not defined for a matrix with no rows');
        var centered = center(A);
        return centered
            .transpose()
            .multiply(centered)
            .scalarMultiply(dimInverse);
    }
}
exports.covariance = covariance;
function correlation(xOrA, s) {
    if (typeGuards_1.isVector(xOrA)) {
        var first = xOrA;
        var second = s;
        var ops = first.ops();
        var dim = first.getDimension();
        if (dim === 0)
            throw Error('Correlation is not defined for vectors of dimension 0');
        if (second.getDimension() !== dim)
            throw Error('Correlation is not defined for vectors of different lengths');
        var ip = standardize(first).innerProduct(standardize(second));
        return ops.divide(ip, ops.fromNumber(dim));
    }
    else {
        var A = xOrA;
        var ops = A.ops();
        var rows = A.getNumberOfRows();
        var dim = ops.fromNumber(rows);
        var dimInverse = ops.getMultiplicativeInverse(dim);
        if (dimInverse === undefined)
            throw Error('The correlation matrix is not defined for a matrix with no rows');
        var centered = standardize(A);
        return centered
            .transpose()
            .multiply(centered)
            .scalarMultiply(dimInverse);
    }
}
exports.correlation = correlation;
//# sourceMappingURL=DescriptiveStatistics.js.map