"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LinearSolution_1 = require("./LinearSolution");
/**
 * Uses forward substitution to solve the linear system _Lx=b_ for a lower-triangular matrix `L`.
 * If `L` is not lower-triangular, the results will be incorrect.
 *
 * @param L - The lower-triangular matrix `L` in _Lx=b_
 * @param b - The vector `b` in _Lx=b_
 * @returns The vector `x` in _Lx=b_
 * @public
 */
function solveByForwardSubstitution(L, b) {
    var ops = L.ops();
    var vectorBuilder = L.vectorBuilder();
    var _a = L.getShape(), numRows = _a[0], numCols = _a[1];
    var solution = [];
    // A system cannot have a unique solution if the matrix is wider than it is tall
    var isUnique = numRows >= numCols;
    for (var rowIndex = 0; rowIndex < numRows; rowIndex++) {
        var sum = ops.zero();
        for (var colIndex = 0; colIndex < rowIndex; colIndex++) {
            sum = ops.add(sum, ops.multiply(L.getEntry(rowIndex, colIndex), solution[colIndex]));
        }
        if (rowIndex < numCols) {
            // Calculate the entry to include in the solution vector
            var entryNumerator = ops.subtract(b.getEntry(rowIndex), sum);
            var entryDenominator = L.getEntry(rowIndex, rowIndex);
            var entry = ops.divide(entryNumerator, entryDenominator);
            if (!ops.equals(entryNumerator, ops.zero()) && ops.equals(entryDenominator, ops.zero())) {
                return {
                    solutionType: LinearSolution_1.SolutionType.OVERDETERMINED
                };
            }
            else if (entry === undefined || ops.equals(entryDenominator, ops.zero())) {
                isUnique = false;
                entry = ops.one(); // Anything will do.
            }
            solution[rowIndex] = entry;
        }
        else {
            // We are done with the solution - just check whether the
            // remaining rows make the system inconsistent
            if (!ops.equals(ops.subtract(b.getEntry(rowIndex), sum), ops.zero())) {
                return {
                    solutionType: LinearSolution_1.SolutionType.OVERDETERMINED
                };
            }
        }
    }
    if (isUnique) {
        return {
            solutionType: LinearSolution_1.SolutionType.UNIQUE,
            solution: vectorBuilder.fromArray(solution)
        };
    }
    else {
        return {
            solutionType: LinearSolution_1.SolutionType.UNDERDETERMINED,
            solution: vectorBuilder.fromArray(solution)
        };
    }
}
exports.solveByForwardSubstitution = solveByForwardSubstitution;
/**
 * Uses forward substitution on the augmented matrix L|b to solve the linear system _Lx=b_ for a
 * lower-triangular matrix `L`.
 * If `L` is not lower-triangular, the results will be incorrect.
 *
 * @param augmented - The augmented matrix `L|b` in _Lx=b_
 * @returns The vector `x` in _Lx=b_
 * @public
 */
function forwardSubstituteAugmentedMatrix(augmented) {
    var L = augmented
        .builder()
        .slice(augmented, 0, 0, augmented.getNumberOfRows(), augmented.getNumberOfColumns() - 1);
    var b = augmented.getColumn(augmented.getNumberOfColumns() - 1);
    return solveByForwardSubstitution(L, b);
}
exports.forwardSubstituteAugmentedMatrix = forwardSubstituteAugmentedMatrix;
/**
 * Uses backward substitution to solve the linear system _Ux=b_ for an upper-triangular matrix `U`.
 * If `U` is not lower-triangular, the results will be incorrect.
 *
 * @param U - The lower-triangular matrix `U` in _Ux=b_
 * @param b - The vector `b` in _Ux=b_
 * @returns The vector `x` in _Ux=b_
 * @public
 */
function solveByBackwardSubstitution(U, b) {
    var ops = U.ops();
    var vectorBuilder = U.vectorBuilder();
    var _a = U.getShape(), numRows = _a[0], numCols = _a[1];
    var solution = [];
    // A system cannot have a unique solution if the matrix is wider than it is tall
    var isUnique = numRows >= numCols;
    for (var rowIndex = numRows - 1; rowIndex >= 0; rowIndex--) {
        if (rowIndex >= numCols) {
            // The matrix entries must be 0, so check if the b entries
            // are nonzero.  If so, the system is inconsistent.
            if (!ops.equals(b.getEntry(rowIndex), ops.zero())) {
                return {
                    solutionType: LinearSolution_1.SolutionType.OVERDETERMINED
                };
            }
        }
        else {
            var sum = ops.zero();
            for (var colIndex = numCols - 1; colIndex > rowIndex; colIndex--) {
                sum = ops.add(sum, ops.multiply(U.getEntry(rowIndex, colIndex), solution[colIndex]));
            }
            var entryNumerator = ops.subtract(b.getEntry(rowIndex), sum);
            var entryDenominator = U.getEntry(rowIndex, rowIndex);
            var entry = ops.divide(entryNumerator, entryDenominator);
            if (!ops.equals(entryNumerator, ops.zero()) && ops.equals(entryDenominator, ops.zero())) {
                return {
                    solutionType: LinearSolution_1.SolutionType.OVERDETERMINED
                };
            }
            else if (entry === undefined || ops.equals(entryDenominator, ops.zero())) {
                isUnique = false;
                entry = ops.one(); // Anything will do.
            }
            solution[rowIndex] = entry;
        }
    }
    if (isUnique) {
        return {
            solutionType: LinearSolution_1.SolutionType.UNIQUE,
            solution: vectorBuilder.fromArray(solution)
        };
    }
    else {
        return {
            solutionType: LinearSolution_1.SolutionType.UNDERDETERMINED,
            solution: vectorBuilder.fromArray(solution)
        };
    }
}
exports.solveByBackwardSubstitution = solveByBackwardSubstitution;
/**
 * Uses backward substitution on the augmented matrix U|b to solve the linear system _Ux=b_ for an
 * upper-triangular matrix `U`.
 * If `U` is not upper-triangular, the results will be incorrect.
 *
 * @param augmented - The augmented matrix `U|b` in _Ux=b_
 * @returns The vector `x` in _Ux=b_
 * @public
 */
function backwardSubstituteAugmentedMatrix(augmented) {
    var U = augmented
        .builder()
        .slice(augmented, 0, 0, augmented.getNumberOfRows(), augmented.getNumberOfColumns() - 1);
    var b = augmented.getColumn(augmented.getNumberOfColumns() - 1);
    return solveByBackwardSubstitution(U, b);
}
exports.backwardSubstituteAugmentedMatrix = backwardSubstituteAugmentedMatrix;
//# sourceMappingURL=Substitution.js.map