"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var NumberUtilities_1 = require("../../utilities/NumberUtilities");
var ComplexNumber_1 = require("./ComplexNumber");
var ScalarOperations_1 = require("./ScalarOperations");
var prettyPrint_1 = require("../../utilities/prettyPrint");
/**
 * Implements the basic {@link ScalarOperations} on {@link ComplexNumber}s
 * @public
 */
var ComplexNumberOperations = /** @class */ (function (_super) {
    __extends(ComplexNumberOperations, _super);
    function ComplexNumberOperations() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * {@inheritdoc ScalarOperations.fromNumber}
     */
    ComplexNumberOperations.prototype.fromNumber = function (num) {
        return new ComplexNumber_1.ComplexNumber(num, 0);
    };
    /**
     * {@inheritdoc ScalarOperations.fromComplex}
     */
    ComplexNumberOperations.prototype.fromComplex = function (real, imag) {
        return new ComplexNumber_1.ComplexNumber(real, imag);
    };
    /**
     * {@inheritdoc ScalarOperations.conjugate}
     */
    ComplexNumberOperations.prototype.conjugate = function (scalar) {
        return scalar.conjugate();
    };
    /**
     * {@inheritdoc ScalarOperations.getAdditiveIdentity}
     */
    ComplexNumberOperations.prototype.getAdditiveIdentity = function () {
        return ComplexNumber_1.ComplexNumber.ZERO;
    };
    /**
     * {@inheritdoc ScalarOperations.getAdditiveInverse}
     */
    ComplexNumberOperations.prototype.getAdditiveInverse = function (scalar) {
        return scalar.getAdditiveInverse();
    };
    /**
     * {@inheritdoc ScalarOperations.getMultiplicativeIdentity}
     */
    ComplexNumberOperations.prototype.getMultiplicativeIdentity = function () {
        return ComplexNumber_1.ComplexNumber.ONE;
    };
    /**
     * {@inheritdoc ScalarOperations.getMultiplicativeInverse}
     */
    ComplexNumberOperations.prototype.getMultiplicativeInverse = function (scalar) {
        return scalar.getMultiplicativeInverse();
    };
    /**
     * {@inheritdoc ScalarOperations.multiply}
     */
    ComplexNumberOperations.prototype.multiply = function (first, second) {
        return first.multiply(second);
    };
    /**
     * {@inheritdoc ScalarOperations.getPrincipalSquareRoot}
     */
    ComplexNumberOperations.prototype.getPrincipalSquareRoot = function (x) {
        if (x.equals(ComplexNumber_1.ComplexNumber.ZERO)) {
            return ComplexNumber_1.ComplexNumber.ZERO;
        }
        var im = x.getImaginaryPart();
        var re = x.getRealPart();
        if (im === 0 && re >= 0) {
            return new ComplexNumber_1.ComplexNumber(Math.sqrt(re), 0);
        }
        else if (im === 0 && re < 0) {
            return new ComplexNumber_1.ComplexNumber(0, Math.sqrt(-re));
        }
        var r = Math.sqrt(Math.pow(re, 2) + Math.pow(im, 2));
        var theta = Math.atan(im / re);
        if (theta < 0) {
            theta = 2 * Math.PI + theta;
        }
        var rootR = Math.sqrt(r);
        var real = rootR * Math.cos(theta / 2);
        var imag = rootR * Math.sin(theta / 2);
        // As with real numbers, x^2 = y has two solutions for all complex y.
        // Unlike with real numbers, there is not really a standard for which
        // value we accept as the principal value for the square root function.
        // However, for our purposes (calculating vector norms), it is useful
        // to choose the value for which the real part is positive.
        if (real > 0) {
            return new ComplexNumber_1.ComplexNumber(real, imag);
        }
        else {
            return new ComplexNumber_1.ComplexNumber(-real, -imag);
        }
    };
    /**
     * {@inheritdoc ScalarOperations.norm}
     */
    ComplexNumberOperations.prototype.norm = function (x) {
        var r = x.getRealPart();
        var i = x.getImaginaryPart();
        return Math.sqrt(r * r + i * i);
    };
    /**
     * {@inheritdoc ScalarOperations.equals}
     */
    ComplexNumberOperations.prototype.equals = function (first, second) {
        return first.equals(second);
    };
    /**
     * {@inheritdoc ScalarOperations.add}
     */
    ComplexNumberOperations.prototype.add = function (first, second) {
        return first.add(second);
    };
    /**
     * {@inheritdoc ScalarOperations.random}
     */
    ComplexNumberOperations.prototype.random = function (min, max) {
        if (min === void 0) { min = 0; }
        if (max === void 0) { max = 1; }
        return new ComplexNumber_1.ComplexNumber(NumberUtilities_1.random(min, max), NumberUtilities_1.random(min, max));
    };
    /**
     * {@inheritdoc ScalarOperations.randomNormal}
     */
    ComplexNumberOperations.prototype.randomNormal = function (mean, standardDeviation) {
        if (mean === void 0) { mean = 0; }
        if (standardDeviation === void 0) { standardDeviation = 1; }
        return new ComplexNumber_1.ComplexNumber(NumberUtilities_1.randomNormal(mean, standardDeviation), NumberUtilities_1.randomNormal(mean, standardDeviation));
    };
    /**
     * {@inheritdoc ScalarOperations.prettyPrint}
     */
    ComplexNumberOperations.prototype.prettyPrint = function (x) {
        return prettyPrint_1.prettyPrint(x.getRealPart()) + " + " + prettyPrint_1.prettyPrint(x.getImaginaryPart()) + "i";
    };
    return ComplexNumberOperations;
}(ScalarOperations_1.ScalarOperations));
exports.ComplexNumberOperations = ComplexNumberOperations;
//# sourceMappingURL=ComplexNumberOperations.js.map