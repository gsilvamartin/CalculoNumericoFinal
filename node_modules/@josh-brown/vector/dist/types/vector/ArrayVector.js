"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../../utilities/ErrorAssertions");
/**
 * Implements {@link Vector} with an array of values.
 *
 * @remarks
 * Subclasses must specify the usual scalar operations on their contents.
 *
 * @public
 */
var ArrayVector = /** @class */ (function () {
    /**
     * @internal
     */
    function ArrayVector(data) {
        this._data = Object.freeze(data);
    }
    /**
     * {@inheritDoc Vector.getEntry}
     */
    ArrayVector.prototype.getEntry = function (index) {
        ErrorAssertions_1.assertValidVectorIndex(this, index);
        return this._data[index];
    };
    /**
     * {@inheritDoc Vector.set}
     */
    ArrayVector.prototype.set = function (index, value) {
        ErrorAssertions_1.assertValidVectorIndex(this, index);
        var newData = this.toArray();
        newData[index] = value;
        return this.builder().fromArray(newData);
    };
    /**
     * {@inheritDoc Vector.add}
     */
    ArrayVector.prototype.add = function (other) {
        var _this = this;
        ErrorAssertions_1.assertHomogeneous([this, other]);
        return this.map(function (entry, index) { return _this.ops().add(entry, other.getEntry(index)); });
    };
    /**
     * {@inheritDoc Vector.equals}
     */
    ArrayVector.prototype.equals = function (other) {
        var _this = this;
        if (this.getDimension() !== other.getDimension()) {
            return false;
        }
        return this._data
            .map(function (entry, i) { return _this.ops().equals(entry, other.getEntry(i)); })
            .reduce(function (all, current) { return all && current; }, true);
    };
    /**
     * {@inheritDoc Vector.innerProduct}
     */
    ArrayVector.prototype.innerProduct = function (other) {
        var _this = this;
        ErrorAssertions_1.assertHomogeneous([this, other]);
        return this._data
            .map(function (entry, index) {
            return _this.ops().multiply(entry, _this.ops().conjugate(other.getEntry(index)));
        })
            .reduce(this.ops().add, this.ops().zero());
    };
    /**
     * {@inheritDoc Vector.outerProduct}
     */
    ArrayVector.prototype.outerProduct = function (other) {
        var _this = this;
        var matrixData = [];
        if (this.getDimension() === 0 || other.getDimension() === 0) {
            return this.matrixBuilder().fromArray(matrixData);
        }
        this.forEach(function (thisValue, rowIndex) {
            matrixData[rowIndex] = [];
            other.forEach(function (otherValue, columnIndex) {
                matrixData[rowIndex][columnIndex] = _this.ops().multiply(thisValue, otherValue);
            });
        });
        return this.matrixBuilder().fromArray(matrixData);
    };
    /**
     * {@inheritDoc Vector.projectOnto}
     */
    ArrayVector.prototype.projectOnto = function (u) {
        var oneOverUDotU = this.ops().getMultiplicativeInverse(u.innerProduct(u));
        if (oneOverUDotU === undefined) {
            throw Error("Cannot project onto the 0-vector");
        }
        var uDotV = u.innerProduct(this);
        var magnitudeOfProjection = this.ops().multiply(uDotV, oneOverUDotU);
        return u.scalarMultiply(magnitudeOfProjection);
    };
    /**
     * {@inheritDoc Vector.scalarMultiply}
     */
    ArrayVector.prototype.scalarMultiply = function (scalar) {
        var _this = this;
        return this.map(function (entry) { return _this.ops().multiply(entry, scalar); });
    };
    /**
     * {@inheritDoc Vector.toArray}
     */
    ArrayVector.prototype.toArray = function () {
        return __spreadArrays(this._data);
    };
    /**
     * {@inheritDoc Vector.getSparseData}
     */
    ArrayVector.prototype.getSparseData = function () {
        var ops = this.ops();
        var zero = ops.zero();
        var sparseData = new Map();
        this.forEach(function (value, index) {
            if (!ops.equals(zero, value)) {
                sparseData.set(index, value);
            }
        });
        return sparseData;
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    ArrayVector.prototype.getDimension = function () {
        return this._data.length;
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    ArrayVector.prototype.forEach = function (callback) {
        this._data.forEach(callback);
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    ArrayVector.prototype.map = function (valueFromEntry) {
        return this.builder().fromArray(this._data.map(valueFromEntry));
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    ArrayVector.prototype.combine = function (other, combineEntries) {
        ErrorAssertions_1.assertHomogeneous([this, other]);
        return this.map(function (entry, index) { return combineEntries(entry, other.getEntry(index)); });
    };
    return ArrayVector;
}());
exports.ArrayVector = ArrayVector;
//# sourceMappingURL=ArrayVector.js.map