"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../../utilities/ErrorAssertions");
/**
 * A type guard which returns true if the input is an instance of `SparseVector`,
 * and functions as a type check in the compiler.
 *
 * @internal
 */
function isSparse(vector) {
    return vector._sparseData !== undefined; // eslint-disable-line @typescript-eslint/no-explicit-any
}
exports.isSparse = isSparse;
/**
 * Implements {@link Vector} as a map of indices to nonzero values.
 *
 * @remarks
 * For large vectors with many entries equal to 0, some operations are
 * more efficient with a {@link Vector} implementation that only stores the non-zero values.
 *
 * Subclasses must specify the usual scalar operations on their contents.
 *
 * @public
 */
var SparseVector = /** @class */ (function () {
    /**
     * @internal
     */
    function SparseVector(data) {
        var _this = this;
        this._dimension = data.length;
        var sparseData = new Map();
        data.forEach(function (value, index) {
            if (!_this.ops().equals(_this.ops().zero(), value)) {
                sparseData.set(index, value);
            }
        });
        this._sparseData = sparseData;
    }
    /**
     * {@inheritDoc Vector.getSparseData}
     */
    SparseVector.prototype.getSparseData = function () {
        return new Map(this._sparseData);
    };
    /**
     * {@inheritDoc Vector.toArray}
     */
    SparseVector.prototype.toArray = function () {
        var data = [];
        for (var i = 0; i < this.getDimension(); i++) {
            data[i] = this.getEntry(i);
        }
        return data;
    };
    /**
     * {@inheritDoc Vector.getEntry}
     */
    SparseVector.prototype.getEntry = function (index) {
        ErrorAssertions_1.assertValidVectorIndex(this, index);
        return this._sparseData.get(index) || this.ops().zero();
    };
    /**
     * {@inheritDoc Vector.set}
     */
    SparseVector.prototype.set = function (index, value) {
        ErrorAssertions_1.assertValidVectorIndex(this, index);
        var newData = this.getSparseData();
        newData.set(index, value);
        return this.builder().fromSparseData(this.getDimension(), newData);
    };
    /**
     * {@inheritDoc Vector.innerProduct}
     */
    SparseVector.prototype.innerProduct = function (other) {
        var _this = this;
        ErrorAssertions_1.assertHomogeneous([this, other]);
        var innerProduct = this.ops().zero();
        this._sparseData.forEach(function (value, index) {
            innerProduct = _this.ops().add(innerProduct, _this.ops().multiply(value, _this.ops().conjugate(other.getEntry(index))));
        });
        return innerProduct;
    };
    /**
     * {@inheritDoc Vector.outerProduct}
     */
    SparseVector.prototype.outerProduct = function (other) {
        var _this = this;
        if (isSparse(other)) {
            return this.outerProductWithSparse(other);
        }
        var matrixData = [];
        if (this.getDimension() === 0 || other.getDimension() === 0) {
            return this.matrixBuilder().fromArray(matrixData);
        }
        this.toArray().forEach(function (thisValue, rowIndex) {
            matrixData[rowIndex] = [];
            other.toArray().forEach(function (otherValue, columnIndex) {
                matrixData[rowIndex][columnIndex] = _this.ops().multiply(thisValue, otherValue);
            });
        });
        return this.matrixBuilder().fromArray(matrixData);
    };
    /**
     * {@inheritDoc Vector.scalarMultiply}
     */
    SparseVector.prototype.scalarMultiply = function (scalar) {
        var _this = this;
        var newSparseData = new Map();
        this._sparseData.forEach(function (value, index) {
            newSparseData.set(index, _this.ops().multiply(value, scalar));
        });
        return this.builder().fromSparseData(this._dimension, newSparseData);
    };
    /**
     * {@inheritDoc Vector.add}
     */
    SparseVector.prototype.add = function (other) {
        var _this = this;
        ErrorAssertions_1.assertHomogeneous([this, other]);
        return this.builder().fromIndexFunction(this._dimension, function (i) {
            return _this.ops().add(_this.getEntry(i), other.getEntry(i));
        });
    };
    /**
     * {@inheritDoc Vector.equals}
     */
    SparseVector.prototype.equals = function (other) {
        var _this = this;
        if (isSparse(other)) {
            return this.equalsSparse(other);
        }
        return other
            .toArray()
            .map(function (entry, i) { return _this.ops().equals(_this.getEntry(i), entry); })
            .reduce(function (all, current) { return all && current; }, true);
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    SparseVector.prototype.getDimension = function () {
        return this._dimension;
    };
    /**
     * {@inheritDoc Vector.projectOnto}
     */
    SparseVector.prototype.projectOnto = function (u) {
        var oneOverUDotU = this.ops().getMultiplicativeInverse(u.innerProduct(u));
        if (oneOverUDotU === undefined) {
            throw Error("Cannot project onto the 0-vector");
        }
        var uDotV = u.innerProduct(this);
        var magnitudeOfProjection = this.ops().multiply(uDotV, oneOverUDotU);
        return u.scalarMultiply(magnitudeOfProjection);
    };
    SparseVector.prototype.equalsSparse = function (other) {
        var _this = this;
        if (this._sparseData.size !== other._sparseData.size) {
            return false;
        }
        var hasMismatch = false;
        this._sparseData.forEach(function (value, index) {
            if (!_this.ops().equals(other.getEntry(index), value)) {
                hasMismatch = true;
            }
        });
        // It is sufficient to check in one direction since they have the same number of elements.
        return !hasMismatch;
    };
    /**
     * If *both* vectors are sparse, then we can do some additional optimization.
     *
     * @param other - The vector with which to perform an outer product
     */
    SparseVector.prototype.outerProductWithSparse = function (other) {
        var _this = this;
        // TODO - use a sparse matrix here
        var m = this.getDimension();
        var n = other.getDimension();
        if (m === 0 || n === 0)
            return this.matrixBuilder().empty();
        var newData = new Map();
        this._sparseData.forEach(function (value, rowIndex) {
            other.getSparseData().forEach(function (otherValue, colIndex) {
                var newValue = _this.ops().multiply(value, otherValue);
                var row = newData.get(rowIndex);
                if (!row) {
                    var newRow = new Map();
                    newRow.set(colIndex, newValue);
                    newData.set(rowIndex, newRow);
                }
                else {
                    row.set(colIndex, newValue);
                }
            });
        });
        return this.matrixBuilder().fromSparseData([m, n], newData);
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    SparseVector.prototype.forEach = function (callback) {
        this.toArray().forEach(callback);
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    SparseVector.prototype.map = function (valueFromEntry) {
        return this.builder().fromArray(this.toArray().map(valueFromEntry));
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    SparseVector.prototype.combine = function (other, combineEntries) {
        ErrorAssertions_1.assertHomogeneous([this, other]);
        return this.map(function (entry, index) { return combineEntries(entry, other.getEntry(index)); });
    };
    return SparseVector;
}());
exports.SparseVector = SparseVector;
//# sourceMappingURL=SparseVector.js.map