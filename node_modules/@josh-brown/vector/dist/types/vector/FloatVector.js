"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var StaticImplements_1 = require("../../utilities/StaticImplements");
var NumberOperations_1 = require("../scalar/NumberOperations");
var VectorBuilder_1 = require("./VectorBuilder");
var ErrorAssertions_1 = require("../../utilities/ErrorAssertions");
var FloatMatrix_1 = require("../matrix/FloatMatrix");
/**
 * A dense {@link Vector} of `number`s implemented as a `Float64Array`
 * @public
 */
var FloatVector = /** @class */ (function () {
    /**
     * @internal
     */
    function FloatVector(data) {
        if (data instanceof Float64Array) {
            this._data = data;
        }
        else {
            this._data = Float64Array.from(data);
        }
    }
    FloatVector_1 = FloatVector;
    FloatVector.ops = function () {
        return new NumberOperations_1.NumberOperations();
    };
    FloatVector.builder = function () {
        return new VectorBuilder_1.VectorBuilder(FloatVector_1);
    };
    /**
     * {@inheritDoc ArrayVector.ops}
     */
    FloatVector.prototype.ops = function () {
        return FloatVector_1.ops();
    };
    /**
     * {@inheritDoc ArrayVector.builder}
     */
    FloatVector.prototype.builder = function () {
        return FloatVector_1.builder();
    };
    /**
     * {@inheritDoc ArrayVector.matrixBuilder}
     */
    FloatVector.prototype.matrixBuilder = function () {
        return FloatMatrix_1.FloatMatrix.builder();
    };
    /**
     * {@inheritDoc Vector.getEntry}
     */
    FloatVector.prototype.getEntry = function (index) {
        ErrorAssertions_1.assertValidVectorIndex(this, index);
        return this._data[index];
    };
    /**
     * {@inheritDoc Vector.set}
     */
    FloatVector.prototype.set = function (index, value) {
        ErrorAssertions_1.assertValidVectorIndex(this, index);
        var newData = Float64Array.from(this._data);
        newData[index] = value;
        return new FloatVector_1(newData);
    };
    /**
     * {@inheritDoc Vector.add}
     */
    FloatVector.prototype.add = function (other) {
        ErrorAssertions_1.assertHomogeneous([this, other]);
        var newData = new Float64Array(this._data);
        for (var i = 0; i < this.getDimension(); i++) {
            newData[i] = this._data[i] + other.getEntry(i);
        }
        return new FloatVector_1(newData);
    };
    /**
     * {@inheritDoc Vector.equals}
     */
    FloatVector.prototype.equals = function (other) {
        if (this.getDimension() !== other.getDimension()) {
            return false;
        }
        var ops = this.ops();
        for (var i = 0; i < this.getDimension(); i++) {
            if (!ops.equals(this._data[i], other.getEntry(i)))
                return false;
        }
        return true;
    };
    /**
     * {@inheritDoc Vector.innerProduct}
     */
    FloatVector.prototype.innerProduct = function (other) {
        ErrorAssertions_1.assertHomogeneous([this, other]);
        var sum = 0;
        for (var i = 0; i < this.getDimension(); i++) {
            sum += this._data[i] * other.getEntry(i);
        }
        return sum;
    };
    /**
     * {@inheritDoc Vector.outerProduct}
     */
    FloatVector.prototype.outerProduct = function (other) {
        var m = this.getDimension();
        var n = other.getDimension();
        if (!m || !n)
            return new FloatMatrix_1.FloatMatrix(new Float64Array(0), [0, 0]);
        var matrixData = new Float64Array(m * n);
        for (var j = 0; j < n; j++) {
            for (var i = 0; i < m; i++) {
                matrixData[j * m + i] = this._data[i] * other.getEntry(j);
            }
        }
        return new FloatMatrix_1.FloatMatrix(matrixData, [m, n]);
    };
    /**
     * {@inheritDoc Vector.projectOnto}
     */
    FloatVector.prototype.projectOnto = function (u) {
        var uDotU = u.innerProduct(u);
        if (uDotU === 0)
            throw new Error("Cannot project onto the 0-vector");
        var oneOverUDotU = 1 / uDotU;
        var uDotV = u.innerProduct(this);
        var magnitudeOfProjection = uDotV * oneOverUDotU;
        return u.scalarMultiply(magnitudeOfProjection);
    };
    /**
     * {@inheritDoc Vector.scalarMultiply}
     */
    FloatVector.prototype.scalarMultiply = function (scalar) {
        return this.map(function (v) { return v * scalar; });
    };
    /**
     * {@inheritDoc Vector.toArray}
     */
    FloatVector.prototype.toArray = function () {
        return Array.from(this._data);
    };
    /**
     * {@inheritDoc Vector.getSparseData}
     */
    FloatVector.prototype.getSparseData = function () {
        var sparseData = new Map();
        this.forEach(function (value, index) {
            if (value !== 0) {
                sparseData.set(index, value);
            }
        });
        return sparseData;
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    FloatVector.prototype.getDimension = function () {
        return this._data.length;
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    FloatVector.prototype.forEach = function (callback) {
        this._data.forEach(callback);
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    FloatVector.prototype.map = function (valueFromEntry) {
        return new FloatVector_1(this._data.map(valueFromEntry));
    };
    /**
     * {@inheritDoc Vector.getDimension}
     */
    FloatVector.prototype.combine = function (other, combineEntries) {
        ErrorAssertions_1.assertHomogeneous([this, other]);
        return this.map(function (entry, index) { return combineEntries(entry, other.getEntry(index)); });
    };
    var FloatVector_1;
    FloatVector = FloatVector_1 = __decorate([
        StaticImplements_1.StaticImplements(),
        __metadata("design:paramtypes", [Object])
    ], FloatVector);
    return FloatVector;
}());
exports.FloatVector = FloatVector;
//# sourceMappingURL=FloatVector.js.map