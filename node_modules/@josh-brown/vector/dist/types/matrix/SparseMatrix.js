"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../../utilities/ErrorAssertions");
// TODO - implement sparse vector/matrix as:
// [number, S][]
// [number, number, S][]
/**
 * Implements {@link Matrix} with a map of indices to nonzero values.
 *
 * @remarks
 * Subclasses must specify the usual scalar operations on their contents.
 *
 * @public
 */
var SparseMatrix = /** @class */ (function () {
    /**
     * @internal
     */
    function SparseMatrix(data) {
        ErrorAssertions_1.assertRectangular(data);
        if (data.length === 0 || data[0].length === 0) {
            data = [];
        }
        var m = data.length;
        var n = data.length > 0 ? data[0].length : 0;
        this._shape = [m, n];
        var sparseData = new Map();
        if (m === 0 || n === 0) {
            this._sparseData = sparseData;
            return;
        }
        data.forEach(function (rowData, rowIndex) {
            rowData.forEach(function (entry, colIndex) {
                var existingRowMap = sparseData.get(rowIndex);
                if (existingRowMap) {
                    existingRowMap.set(colIndex, entry);
                }
                else {
                    var rowMap = new Map();
                    rowMap.set(colIndex, entry);
                    sparseData.set(rowIndex, rowMap);
                }
            });
        });
        this._sparseData = sparseData;
    }
    /**
     * {@inheritDoc Matrix.add}
     */
    SparseMatrix.prototype.add = function (other) {
        return this.builder().fromColumnVectors(this.getColumnVectors().map(function (column, columnIndex) { return column.add(other.getColumn(columnIndex)); }));
    };
    /**
     * {@inheritDoc Matrix.adjoint}
     */
    SparseMatrix.prototype.adjoint = function () {
        var _this = this;
        var adjointData = this.transpose().getSparseData();
        adjointData.forEach(function (rd) {
            rd.forEach(function (value, colIndex) {
                rd.set(colIndex, _this.ops().conjugate(value));
            });
        });
        var _a = this._shape, m = _a[0], n = _a[1];
        return this.builder().fromSparseData([n, m], adjointData);
    };
    /**
     * {@inheritDoc Matrix.trace}
     */
    SparseMatrix.prototype.trace = function () {
        var ops = this.ops();
        var trace = ops.zero();
        var n = Math.min.apply(Math, this.getShape());
        for (var i = 0; i < n; i++) {
            trace = ops.add(trace, this.getEntry(i, i));
        }
        return trace;
    };
    /**
     * {@inheritDoc Matrix.apply}
     */
    SparseMatrix.prototype.apply = function (vector) {
        var vectorAsColumnMatrix = this.builder().fromColumnVectors([vector]);
        return this.multiply(vectorAsColumnMatrix).getColumn(0);
    };
    /**
     * {@inheritDoc Matrix.equals}
     */
    SparseMatrix.prototype.equals = function (other) {
        if (this.getNumberOfColumns() !== other.getNumberOfColumns()) {
            return false;
        }
        if (this.getNumberOfRows() !== other.getNumberOfRows()) {
            return false;
        }
        // TODO - can probably be optimized for the case of two sparse matrices
        return this.getColumnVectors()
            .map(function (column, i) { return column.equals(other.getColumn(i)); })
            .reduce(function (all, current) { return all && current; }, true);
    };
    /**
     * {@inheritDoc Matrix.getColumn}
     */
    SparseMatrix.prototype.getColumn = function (j) {
        ErrorAssertions_1.assertValidIndex(j, this.getNumberOfColumns());
        return this.getColumnVectors()[j];
    };
    /**
     * {@inheritDoc Matrix.getColumnVectors}
     */
    SparseMatrix.prototype.getColumnVectors = function () {
        return this.transpose().getRowVectors();
    };
    /**
     * {@inheritDoc Matrix.getDiagonal}
     */
    SparseMatrix.prototype.getDiagonal = function () {
        var _this = this;
        var numDiagonalElements = Math.min(this.getNumberOfRows(), this.getNumberOfColumns());
        return this.vectorBuilder().fromIndexFunction(numDiagonalElements, function (i) { return _this.getEntry(i, i); });
    };
    /**
     * {@inheritDoc Matrix.toArray}
     */
    SparseMatrix.prototype.toArray = function () {
        return this.getRowVectors().map(function (row) { return __spreadArrays(row.toArray()); });
    };
    /**
     * {@inheritDoc Matrix.getSparseData}
     */
    SparseMatrix.prototype.getSparseData = function () {
        var ops = this.ops();
        var zero = ops.zero();
        var sparseData = new Map();
        this._sparseData.forEach(function (oldRowData, rowIndex) {
            oldRowData.forEach(function (value, colIndex) {
                if (ops.equals(zero, value)) {
                    return;
                }
                var rowData = sparseData.get(rowIndex);
                if (rowData) {
                    rowData.set(colIndex, value);
                }
                else {
                    var newRowData = new Map();
                    newRowData.set(colIndex, value);
                    sparseData.set(rowIndex, newRowData);
                }
            });
        });
        return sparseData;
    };
    /**
     * {@inheritDoc Matrix.getEntry}
     */
    SparseMatrix.prototype.getEntry = function (i, j) {
        ErrorAssertions_1.assertValidMatrixIndex(this, i, j);
        var rowData = this._sparseData.get(i);
        if (!rowData) {
            return this.ops().zero();
        }
        return rowData.get(j) || this.ops().zero();
    };
    /**
     * {@inheritDoc Matrix.getShape}
     */
    SparseMatrix.prototype.getShape = function () {
        var _a = this._shape, m = _a[0], n = _a[1];
        return [m, n];
    };
    /**
     * {@inheritDoc Matrix.getNumberOfColumns}
     */
    SparseMatrix.prototype.getNumberOfColumns = function () {
        return this._shape[1];
    };
    /**
     * {@inheritDoc Matrix.getNumberOfRows}
     */
    SparseMatrix.prototype.getNumberOfRows = function () {
        return this._shape[0];
    };
    /**
     * {@inheritDoc Matrix.getRow}
     */
    SparseMatrix.prototype.getRow = function (i) {
        var _a = this._shape, m = _a[0], n = _a[1];
        ErrorAssertions_1.assertValidIndex(i, m);
        return this.vectorBuilder().fromSparseData(n, this._sparseData.get(i) || new Map());
    };
    /**
     * {@inheritDoc Matrix.getRowVectors}
     */
    SparseMatrix.prototype.getRowVectors = function () {
        var m = this._shape[0];
        var rowVectors = [];
        for (var i = 0; i < m; i++) {
            rowVectors.push(this.getRow(i));
        }
        return rowVectors;
    };
    /**
     * {@inheritDoc Matrix.multiply}
     */
    SparseMatrix.prototype.multiply = function (other) {
        ErrorAssertions_1.assertMultiplicable(this, other);
        // TODO - can probably be optimized for the case of two sparse matrices
        return this.builder().fromArray(this.getRowVectors().map(function (row) {
            return other.getColumnVectors().map(function (column) { return row.innerProduct(column); });
        }));
    };
    /**
     * {@inheritDoc Matrix.scalarMultiply}
     */
    SparseMatrix.prototype.scalarMultiply = function (scalar) {
        var _this = this;
        var sd = this.getSparseData();
        sd.forEach(function (rd) {
            rd.forEach(function (value, colIndex) {
                rd.set(colIndex, _this.ops().multiply(value, scalar));
            });
        });
        return this.builder().fromSparseData(this._shape, sd);
    };
    /**
     * {@inheritDoc Matrix.set}
     */
    SparseMatrix.prototype.set = function (i, j, value) {
        ErrorAssertions_1.assertValidMatrixIndex(this, i, j);
        var copy = this.getSparseData();
        var row = copy.get(i);
        if (row) {
            row.set(j, value);
        }
        else {
            var newRow = new Map();
            newRow.set(j, value);
            copy.set(i, newRow);
        }
        return this.builder().fromSparseData(this._shape, copy);
    };
    /**
     * {@inheritDoc Matrix.transpose}
     */
    SparseMatrix.prototype.transpose = function () {
        var transposeData = new Map();
        this._sparseData.forEach(function (sparseRowData, rowIndex) {
            sparseRowData.forEach(function (value, colIndex) {
                var transposeRowData = transposeData.get(colIndex);
                if (transposeRowData) {
                    transposeRowData.set(rowIndex, value);
                }
                else {
                    var newTransposeRowData = new Map();
                    newTransposeRowData.set(rowIndex, value);
                    transposeData.set(colIndex, newTransposeRowData);
                }
            });
        });
        var _a = this._shape, m = _a[0], n = _a[1];
        return this.builder().fromSparseData([n, m], transposeData);
    };
    /**
     * {@inheritDoc Matrix.forEach}
     */
    SparseMatrix.prototype.forEach = function (cb) {
        this.getRowVectors().forEach(function (row, i) {
            row.forEach(function (entry, j) {
                cb(entry, i, j);
            });
        });
    };
    /**
     * {@inheritDoc Matrix.map}
     */
    SparseMatrix.prototype.map = function (entryFunction) {
        var newRows = this.getRowVectors().map(function (row, rowIndex) {
            return row.map(function (entry, colIndex) { return entryFunction(entry, rowIndex, colIndex); });
        });
        return this.builder().fromRowVectors(newRows);
    };
    /**
     * {@inheritDoc Matrix.combine}
     */
    SparseMatrix.prototype.combine = function (other, combineEntries) {
        ErrorAssertions_1.assertDimensionMatch(this, other);
        return this.map(function (entry, i, j) { return combineEntries(entry, other.getEntry(i, j)); });
    };
    return SparseMatrix;
}());
exports.SparseMatrix = SparseMatrix;
//# sourceMappingURL=SparseMatrix.js.map