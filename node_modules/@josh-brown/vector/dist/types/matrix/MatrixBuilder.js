"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../../utilities/ErrorAssertions");
var NumberUtilities_1 = require("../../utilities/NumberUtilities");
/**
 * Provides methods for constructing {@link Matrix | Matrices} of a given type
 * @public
 */
var MatrixBuilder = /** @class */ (function () {
    /**
     * @internal
     */
    function MatrixBuilder(matrixConstructor) {
        this._matrixConstructor = matrixConstructor;
    }
    MatrixBuilder.prototype.fromArray = function (data) {
        return new this._matrixConstructor(data);
    };
    MatrixBuilder.prototype.fromNumberArray = function (numberData) {
        var ops = this.ops();
        var data = numberData.map(function (dataRow) { return dataRow.map(function (num) { return ops.fromNumber(num); }); });
        return this.fromArray(data);
    };
    MatrixBuilder.prototype.fromSparseData = function (shape, sparseData) {
        ErrorAssertions_1.assertValidShape(shape);
        var m = shape[0], n = shape[1];
        var data = this.zeros([m, n]).toArray();
        sparseData.forEach(function (sparseRowData, rowIndex) {
            sparseRowData.forEach(function (value, colIndex) {
                data[rowIndex][colIndex] = value;
            });
        });
        return this.fromArray(data);
    };
    /**
     * Builds a matrix from an array of column vectors
     *
     * @example
     * ```
     * const firstColumn = vectorBuilder.fromArray([ 1, 2, 3 ]);
     * const secondColumn = vectorBuilder.fromArray([ 4, 5, 6 ]);
     *
     * const matrix = matrixBuilder.fromColumnVectors([ firstColumn, secondColumn ]);
     *
     * // [ 1 4 ]
     * // [ 2 5 ]
     * // [ 3 6 ]
     * ```
     * @param columns - The vectors to use as the columns of the new matrix
     * @public
     */
    MatrixBuilder.prototype.fromColumnVectors = function (columns) {
        ErrorAssertions_1.assertHomogeneous(columns);
        var numberOfColumns = columns.length;
        if (numberOfColumns === 0) {
            return this.empty();
        }
        var numberOfRows = columns[0].getDimension();
        if (numberOfRows === 0) {
            return this.empty();
        }
        return this.fromIndexFunction([numberOfRows, numberOfColumns], function (i, j) {
            return columns[j].getEntry(i);
        });
    };
    /**
     * Builds a matrix from an array of row vectors
     *
     * @example
     * ```
     * const firstRow = vectorBuilder.fromArray([ 1, 2, 3 ]);
     * const secondRow = vectorBuilder.fromArray([ 4, 5, 6 ]);
     *
     * const matrix = matrixBuilder.fromRowVectors([ firstRow, secondRow ]);
     *
     * // [ 1 2 3 ]
     * // [ 4 5 6 ]
     * ```
     *
     * @param rows - The vectors to use as the rows of the new matrix
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.fromRowVectors = function (rows) {
        ErrorAssertions_1.assertHomogeneous(rows);
        var numberOfRows = rows.length;
        if (numberOfRows === 0) {
            return this.empty();
        }
        var numberOfColumns = rows[0].getDimension();
        if (numberOfColumns === 0) {
            return this.empty();
        }
        return this.fromIndexFunction([numberOfRows, numberOfColumns], function (i, j) { return rows[i].getEntry(j); });
    };
    /**
     * Builds a matrix with entries given by _entry = f(i, j)_ where _f_ is `indexFunction`
     * and `i` and `j` are the indices of the element
     *
     * @example
     * ```
     * const matrix = matrixBuilder.fromIndexFunction(3, 4, (i, j) => i + j + 3);
     *
     * // [ 3 4 5 6 ]
     * // [ 4 5 6 7 ]
     * // [ 5 6 7 8 ]
     * ```
     * @param shape - The shape of the matrix as a tuple
     * @param indexFunction - A function returning the entry for a given `i`, `j`
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.fromIndexFunction = function (shape, indexFunction) {
        ErrorAssertions_1.assertValidShape(shape);
        var m = shape[0], n = shape[1];
        var data = [];
        for (var i = 0; i < m; i++) {
            data[i] = [];
            for (var j = 0; j < n; j++) {
                data[i][j] = indexFunction(i, j);
            }
        }
        return new this._matrixConstructor(data);
    };
    /**
     * Constructs a 0x0 matrix
     *
     * @example
     * ```
     * matrixBuilder.empty(); // []
     * ```
     *
     * @public
     */
    MatrixBuilder.prototype.empty = function () {
        return new this._matrixConstructor([]);
    };
    /**
     * Constructs a matrix of the specified dimension, whose entries are all the specified value
     *
     * @example
     * ```
     * const allTwos = matrixBuilder.fill(2, 3, 4)
     *
     * // [ 2 2 2 2 ]
     * // [ 2 2 2 2 ]
     * // [ 2 2 2 2 ]
     * ```
     *
     * @param value - The value that should be used for every entry in the new matrix
     * @param shape - The shape of the matrix as a tuple
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.fill = function (value, shape) {
        return this.fromIndexFunction(shape, function () { return value; });
    };
    /**
     * Constructs a matrix of the specified dimensions, consisting of all zeros
     *
     * @example
     * ```
     * const allZeros = matrixBuilder.zeros([2, 3]);
     *
     * // [ 0 0 0 ]
     * // [ 0 0 0 ]
     * ```
     * @param shape - the shape of the matrix as a tuple
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.zeros = function (shape) {
        return this.fill(this.ops().zero(), shape);
    };
    /**
     * Constructs a matrix of the specified dimensions, consisting of all ones
     *
     * @example
     * ```
     * const allOnes = matrixBuilder.ones(2, 3);
     *
     * // [ 1 1 1 ]
     * // [ 1 1 1 ]
     * ```
     * @param shape - the shape of the matrix as a tuple
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.ones = function (shape) {
        return this.fill(this.ops().one(), shape);
    };
    /**
     * Constructs a `size` x `size` identity matrix
     *
     * @example
     * ```
     * const I3 = matrixBuilder.identity(3);
     *
     * // [ 1 0 0 ]
     * // [ 0 1 0 ]
     * // [ 0 0 1 ]
     * ```
     * @param size - The dimension of the vector space for which the new matrix is the identity
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.identity = function (size) {
        var _this = this;
        return this.fromIndexFunction([size, size], function (i, j) {
            return i === j ? _this.ops().one() : _this.ops().zero();
        });
    };
    /**
     * Constructs a Hilbert matrix of the specified size
     *
     * @example
     * ```
     * const H = matrixBuilder.hilbert(3);
     *
     * // [  1   1/2  1/3 ]
     * // [ 1/2  1/3  1/4 ]
     * // [ 1/3  1/4  1/5 ]
     * ```
     *
     * @param size - The size of the Hilbert matrix
     * @public
     */
    MatrixBuilder.prototype.hilbert = function (size) {
        var _this = this;
        return this.fromIndexFunction([size, size], function (i, j) {
            return _this.ops().fromNumber(1 / (i + j + 1));
        });
    };
    /**
     * Constructs a Toeplitz matrix from the specified first column and first row.
     * A Toeplitz matrix has constant diagonals.  If `firstRow` is not given, then
     * the complex conjugate of `firstColumn` is assumed.  The first entry must be
     * real because the first entry of the first column must equal the first entry
     * of the first row.
     *
     * @example
     * ```
     * const toeplitz = matrixBuilder.toeplitz(vectorBuilder.fromArray([1, 2, 3]));
     *
     * // [ 1 2 3 ]
     * // [ 2 1 2 ]
     * // [ 3 2 1 ]
     *
     * const toeplitzWithSpecifiedRow = matrixBuilder.toeplitz(
     *   vectorBuilder.fromArray([1, 2, 3]),
     *   vectorBuilder.fromArray([1, 3, 5, 7])
     * );
     *
     * // [ 1 3 5 7 ]
     * // [ 2 1 3 5 ]
     * // [ 3 2 1 3 ]
     * ```
     *
     * @param firstColumn - The first column of the Toeplitz matrix
     * @param firstRow - The first row of the Toeplitz matrix
     * @public
     */
    MatrixBuilder.prototype.toeplitz = function (firstColumn, firstRow) {
        var ops = this.ops();
        firstRow = firstRow || firstColumn.map(function (value) { return ops.conjugate(value); });
        if (firstRow.getDimension() === 0 || firstColumn.getDimension() === 0) {
            return this.empty();
        }
        if (!this.ops().equals(firstRow.getEntry(0), firstColumn.getEntry(0))) {
            throw Error("The first entry of firstColumn must equal the first entry of firstRow");
        }
        return this.fromIndexFunction([firstColumn.getDimension(), firstRow.getDimension()], function (i, j) {
            if (i >= j) {
                return firstColumn.getEntry(i - j);
            }
            else {
                // TODO - review on TSC upgrade - should never be undefined
                return firstRow.getEntry(j - i);
            }
        });
    };
    /**
     * Constructs a Hankel matrix from the specified first column and last row.
     * A Hankel matrix has constant anti-diagonals. If `lastRow` is not given,
     * then a vector with the last entry of the first row in the first entry and
     * zero elsewhere is assumed.  The last entry of the first column must equal
     * the first entry of the last row.
     *
     * @example
     * ```
     * const hankel = matrixBuilder.hankel(vectorBuilder.fromArray([2, 4, 6, 8]));
     *
     * // [ 2 4 6 8 ]
     * // [ 4 6 8 0 ]
     * // [ 6 8 0 0 ]
     * // [ 8 0 0 0 ]
     *
     * const hankelWithSpecifiedRow = matrixBuilder.hankel(
     *   vectorBuilder.fromArray([1, 2, 3, 4]),
     *   vectorBuilder.fromArray([4, 9, 9])
     * );
     *
     * // [ 1 2 3 ]
     * // [ 2 3 4 ]
     * // [ 3 4 9 ]
     * // [ 4 9 9 ]
     * ```
     *
     * @param firstColumn - The first column of the Hankel matrix
     * @param lastRow - The last row of the Hankel matrix
     * @public
     */
    MatrixBuilder.prototype.hankel = function (firstColumn, lastRow) {
        var numRows = firstColumn.getDimension();
        if (numRows === 0) {
            return this.empty();
        }
        lastRow =
            lastRow ||
                firstColumn
                    .builder()
                    .elementaryVector(numRows, 0)
                    .scalarMultiply(firstColumn.getEntry(numRows - 1));
        var numColumns = lastRow.getDimension();
        if (numColumns === 0 ||
            !this.ops().equals(lastRow.getEntry(0), firstColumn.getEntry(numRows - 1))) {
            throw Error("The last entry of firstColumn must equal the first entry of lastRow");
        }
        return this.fromIndexFunction([numRows, numColumns], function (i, j) {
            var index = i + j;
            if (index < numRows) {
                return firstColumn.getEntry(index);
            }
            else {
                // TODO - review on TSC upgrade - should never be undefined
                return lastRow.getEntry(index - numRows + 1);
            }
        });
    };
    /**
     * Constructs a lower-triangular matrix whose entries are the binomial coefficients (j choose i).
     * Constructs an upper triangular matrix when the second argument is `true`.
     *
     * @example
     * ```
     * const pascalLower = matrixBuilder.pascal(4);
     *
     * // [ 1 0 0 0 ]
     * // [ 1 1 0 0 ]
     * // [ 1 2 1 0 ]
     * // [ 1 3 3 1 ]
     *
     * const pascalUpper = matrixBuilder.pascal(4, true);
     *
     * // [ 1 1 1 1 ]
     * // [ 0 1 2 3 ]
     * // [ 0 0 1 3 ]
     * // [ 0 0 0 1 ]
     * ```
     *
     * @param size - The size of the Pascal matrix
     * @param upper - Construct an upper-triangular matrix (i choose j)
     * @public
     */
    MatrixBuilder.prototype.pascal = function (size, upper) {
        var _this = this;
        if (upper === void 0) { upper = false; }
        return this.fromIndexFunction([size, size], function (i, j) {
            var entry = upper ? NumberUtilities_1.binomial(j, i) : NumberUtilities_1.binomial(i, j);
            return _this.ops().fromNumber(entry);
        });
    };
    /**
     * Constructs a symmetric matrix whose entries are the binomial coefficients (i + j choose i)
     *
     * @example
     * ```
     * const pascalSymmetric = matrixBuilder.pascalSymmetric(4);
     *
     * // [ 1  1  1  1  ]
     * // [ 1  2  3  4  ]
     * // [ 1  3  6  10 ]
     * // [ 1  4  10 20 ]
     * ```
     *
     * @param size - The size of the Pascal matrix
     * @public
     */
    MatrixBuilder.prototype.pascalSymmetric = function (size) {
        var _this = this;
        return this.fromIndexFunction([size, size], function (i, j) {
            return _this.ops().fromNumber(NumberUtilities_1.binomial(i + j, i));
        });
    };
    /**
     * Construct a circulant matrix using entries from the input vector
     *
     * @example
     * ```
     * const circulant = matrixBuilder.circulant(vectorBuilder.fromArray([1, 2, 3]));
     *
     * // [ 1 3 2 ]
     * // [ 2 1 3 ]
     * // [ 3 2 1 ]
     * ```
     *
     * @param vector - The vector whose entries to use in the circulant matrix
     * @public
     */
    MatrixBuilder.prototype.circulant = function (vector) {
        var vb = this._matrixConstructor.vectorBuilder();
        var columns = [vector];
        for (var offset = 1; offset < vector.getDimension(); offset++) {
            columns.push(vb.shift(vector, offset, true));
        }
        return this.fromColumnVectors(columns);
    };
    /**
     * Constructs a matrix of the specified size whose entries are (uniformly-distributed) random
     * numbers between `min` and `max`
     *
     * @param shape - The shape of the matrix as a tuple
     * @param min - The lower limit of the random numbers to include
     * @param max - The upper limit of the random numbers to include
     * @public
     */
    MatrixBuilder.prototype.random = function (shape, min, max) {
        var _this = this;
        if (min === void 0) { min = 0; }
        if (max === void 0) { max = 1; }
        if (min >= max) {
            throw Error("Expected min < max; got " + min + " and " + max);
        }
        return this.fromIndexFunction(shape, function () { return _this.ops().random(min, max); });
    };
    /**
     * Constructs a matrix of the specified size whose entries are normally distributed with the
     * specified mean and standard deviation.
     *
     * @param shape - The shape of the matrix as a tuple
     * @param mean - The center of the distribution of random numbers to include
     * @param standardDeviation - The standard deviation of the distribution of random numbers to include
     * @public
     */
    MatrixBuilder.prototype.randomNormal = function (shape, mean, standardDeviation) {
        var _this = this;
        if (mean === void 0) { mean = 0; }
        if (standardDeviation === void 0) { standardDeviation = 1; }
        if (standardDeviation <= 0) {
            throw Error("Expected standardDeviation > 0; got " + standardDeviation);
        }
        return this.fromIndexFunction(shape, function () { return _this.ops().randomNormal(mean, standardDeviation); });
    };
    /**
     * Constructs a square diagonal matrix whose diagonal entries come from `diagonalEntries`
     *
     * @example
     * ```
     * const diagonalEntries = NumberVector.fromValues(1, 2, 3);
     * matrixBuilder.diagonal(diagonalEntries);
     *
     * // [ 1 0 0 ]
     * // [ 0 2 0 ]
     * // [ 0 0 3 ]
     * ```
     * @param diagonalEntries - A vector whose entries will be used as the diagonal entries of the new matrix
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.diagonal = function (diagonalEntries) {
        var _this = this;
        var size = diagonalEntries.getDimension();
        return this.fromIndexFunction([size, size], function (i, j) {
            return i === j ? diagonalEntries.getEntry(i) : _this.ops().zero();
        });
    };
    /**
     * Constructs a square tridiagonal matrix whose diagonal entries correspond to the entries of
     * `diagonalEntries`, whose entries in the left-off-diagonal correspond to the entries
     * of `leftEntries`, and whose entries in the right-off-diagonal correspond fo the
     * entries of `rightEntries`.
     * The off-diagonals must have one fewer entry than the diagonal.
     * Throws an error if the dimensions are not correct.
     *
     * @example
     * ```
     * const leftEntries = NumberVector.fromEntries(1, 2);
     * const diagonalEntries = NumberVector.fromEntries(3, 4, 5);
     * const rightEntries = NumberVector.fromEntries(6, 7);
     *
     * const tridiagonal = matrixBuilder.tridiagonal(leftEntries, diagonalEntries, rightEntries);
     *
     * // [ 3 6 0 ]
     * // [ 1 4 7 ]
     * // [ 0 2 5 ]
     * ```
     *
     * @param leftEntries - A vector whose entries will be used in the left off-diagonal
     * @param diagonalEntries - A vector whose entries will be used in the diagonal
     * @param rightEntries - A vector whose entries will be used in the right off-diagonal
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.tridiagonal = function (leftEntries, diagonalEntries, rightEntries) {
        var _this = this;
        var size = diagonalEntries.getDimension();
        var hasSizeMismatch = leftEntries.getDimension() !== size - 1 || rightEntries.getDimension() !== size - 1;
        if (hasSizeMismatch) {
            throw Error('');
        }
        return this.fromIndexFunction([size, size], function (i, j) {
            if (i === j) {
                return diagonalEntries.getEntry(i);
            }
            else if (i === j + 1) {
                return leftEntries.getEntry(j);
            }
            else if (i === j - 1) {
                return rightEntries.getEntry(i);
            }
            else {
                return _this.ops().zero();
            }
        });
    };
    /**
     * Creates a block-diagonal matrix.
     *
     * @example
     * ```
     * const ones = matrixBuilder.ones(2);
     * const twos = matrixBuilder.fill(2, 3);
     *
     * const blockDiagonal = matrixBuilder.blockDiagonal([ones, twos, ones]);
     *
     * // [ 1 1 0 0 0 0 0 ]
     * // [ 1 1 0 0 0 0 0 ]
     * // [ 0 0 2 2 2 0 0 ]
     * // [ 0 0 2 2 2 0 0 ]
     * // [ 0 0 2 2 2 0 0 ]
     * // [ 0 0 0 0 0 1 1 ]
     * // [ 0 0 0 0 0 1 1 ]
     * ```
     *
     * @param matrices - The matrices to appear along the primary diagonal of the block matrix
     * @public
     */
    MatrixBuilder.prototype.blockDiagonal = function (matrices) {
        var _this = this;
        matrices.forEach(function (matrix) { return ErrorAssertions_1.assertSquare(matrix); });
        var numberOfDiagonalMatrices = matrices.length;
        var grid = matrices.map(function (matrix, index) {
            var row = [];
            for (var i = 0; i < numberOfDiagonalMatrices; i++) {
                if (i === index) {
                    row.push(matrix);
                }
                else {
                    row.push(_this.zeros([matrix.getNumberOfRows(), matrices[i].getNumberOfColumns()]));
                }
            }
            return row;
        });
        return this.block(grid);
    };
    /**
     * Constructs a single matrix consisting of a grid of matrices combined together.
     * Throws an error if any of the dimensions are incompatible.
     *
     * @example
     * ```
     * const upperLeft = matrixBuilder.ones(1, 1);
     * const upperRight = matrixBuilder.fill(2, 1, 2);
     * const lowerLeft = matrixBuilder.fill(3, 2, 1);
     * const lowerRight = matrixBuilder.fill(4, 2, 2);
     *
     * const grid = [
     *   [ upperLeft, upperRight ],
     *   [ lowerLeft, lowerRight ]
     * ];
     *
     * const block = matrixBuilder.block(grid);
     *
     * // [ 1 2 2 ]
     * // [ 3 4 4 ]
     * // [ 3 4 4 ]
     * ```
     * @param grid - A 2-dimensional array of matrices that will be combined into the new matrix
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.block = function (grid) {
        var _this = this;
        if (grid.length === 0 || grid[0].length === 0) {
            return this.empty();
        }
        var data = grid
            .map(function (gridRow) {
            return gridRow.reduce(function (accumulator, gridEntry) {
                return _this.augment(accumulator, gridEntry);
            });
        })
            .reduce(function (accumulator, row) {
            return _this.stack(accumulator, row);
        })
            .toArray();
        return this.fromArray(data);
    };
    /**
     * Constructs a new matrix consisting of `left` and `right` next to one another.
     * Throws an error of `left` and `right` do not have the same number of rows.
     *
     * @example
     * ```
     * const left = matrixBuilder.ones(2);
     * const right = matrixBuilder.zeros(2, 3);
     *
     * matrixBuilder.augment(left, right);
     *
     * // [ 1 1 0 0 0 ]
     * // [ 1 1 0 0 0 ]
     * ```
     * @param left - The matrix that will form the left-side of the augmented matrix
     * @param right - The matrix that will form the right-side of the augmented matrix
     * @returns The new augmented matrix
     * @public
     */
    MatrixBuilder.prototype.augment = function (left, right) {
        if (left.getNumberOfRows() !== right.getNumberOfRows()) {
            throw Error('Dimension mismatch!');
        }
        return this.fromColumnVectors(__spreadArrays(left.getColumnVectors(), right.getColumnVectors()));
    };
    /**
     * Constructs a new matrix consisted of repetitions of a smaller matrix.
     *
     * @example
     * ```
     * const I = matrixBuilder.identity(2);
     * const repeated = matrixBuilder.repeat(I, 1, 2);
     *
     * // [ 1 0 1 0 ]
     * // [ 0 1 0 1 ]
     * ```
     * @param matrix - The matrix to be repeated
     * @param rows - The number of times to repeat the matrix vertically
     * @param columns - The number of times to repeat the matrix horizontally
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.repeat = function (matrix, rows, columns) {
        var grid = [];
        for (var i = 0; i < rows; i++) {
            grid[i] = [];
            for (var j = 0; j < columns; j++) {
                grid[i][j] = matrix;
            }
        }
        return this.block(grid);
    };
    /**
     * Constructs a new matrix based on a rectangular slice of a larger matrix
     *
     * @example
     * ```
     * const matrix = matrixBuilder.identity(4);
     * const slice = matrixBuilder.slice(matrix, 2, 2, 3, 4);
     *
     * // [  1  0  0  0  ]
     * // [  0  1* 0* 0* ]  =>  [ 1 0 0 ]
     * // [  0  0* 1* 0* ]      [ 0 1 0 ]
     * // [  0  0  0  1  ]
     * ```
     *
     * @param matrix - The original matrix
     * @param rowStartIndex - The (inclusive) first row of the slice
     * @param columnStartIndex - The (inclusive) first column of the slice
     * @param rowEndIndex - The (exclusive) last row of the slice
     * @param columnEndIndex - The (exclusive) last column of the slice
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.slice = function (matrix, rowStartIndex, columnStartIndex, rowEndIndex, columnEndIndex) {
        if (rowStartIndex === void 0) { rowStartIndex = 0; }
        if (columnStartIndex === void 0) { columnStartIndex = 0; }
        if (rowEndIndex === void 0) { rowEndIndex = matrix.getNumberOfRows(); }
        if (columnEndIndex === void 0) { columnEndIndex = matrix.getNumberOfColumns(); }
        if (rowStartIndex < 0 || columnStartIndex < 0 || rowEndIndex < 0 || columnEndIndex < 0) {
            throw Error('indices must be positive');
        }
        var _a = matrix.getShape(), m = _a[0], n = _a[1];
        if (rowStartIndex > m || rowEndIndex > m || columnStartIndex > n || columnEndIndex > n) {
            throw Error('index out of bounds');
        }
        if (rowStartIndex > rowEndIndex || columnStartIndex > columnEndIndex) {
            throw Error('start index must be less than end index');
        }
        var data = [];
        var newRowIndex = 0;
        for (var i = rowStartIndex; i < rowEndIndex; i++) {
            data[newRowIndex] = [];
            var newColumnIndex = 0;
            for (var j = columnStartIndex; j < columnEndIndex; j++) {
                data[newRowIndex][newColumnIndex] = matrix.getEntry(i, j);
                newColumnIndex++;
            }
            newRowIndex++;
        }
        return this.fromArray(data);
    };
    /**
     * Constructs a new matrix with all entries in row `rowToExclude` and in
     * column `columnToExclude` removed.
     *
     * @example
     * ```
     * const I = matrixBuilder.identity(4);
     * const excluded = matrixBuilder.slice(I, 1, 2)
     *
     * // [  1  0  0* 0  ]
     * // [  0* 1* 0* 0* ]  =>  [ 1 0 0 ]
     * // [  0  0  1* 0  ]      [ 0 0 0 ]
     * // [  0  0  0* 1  ]      [ 0 0 1 ]
     * ```
     * @param matrix - The input matrix
     * @param rowToExclude - The index of the row that will be removed
     * @param columnToExclude - The index of the column that will be removed
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.exclude = function (matrix, rowToExclude, columnToExclude) {
        ErrorAssertions_1.assertValidMatrixIndex(matrix, rowToExclude, columnToExclude);
        var data = [];
        for (var i = 0; i < matrix.getNumberOfRows(); i++) {
            if (i < rowToExclude) {
                data[i] = [];
                for (var j = 0; j < matrix.getNumberOfColumns(); j++) {
                    if (j < columnToExclude) {
                        data[i][j] = matrix.getEntry(i, j);
                    }
                    else if (j > columnToExclude) {
                        data[i][j - 1] = matrix.getEntry(i, j);
                    }
                }
            }
            else if (i > rowToExclude) {
                data[i - 1] = [];
                for (var j = 0; j < matrix.getNumberOfColumns(); j++) {
                    if (j < columnToExclude) {
                        data[i - 1][j] = matrix.getEntry(i, j);
                    }
                    else if (j > columnToExclude) {
                        data[i - 1][j - 1] = matrix.getEntry(i, j);
                    }
                }
            }
        }
        return this.fromArray(data);
    };
    MatrixBuilder.prototype.ops = function () {
        return this._matrixConstructor.ops();
    };
    /**
     * Constructs a new matrix consisting of `top` and `bottom` on top of one another.
     * Throws an error if `top` and `bottom` do not have the same number of columns.
     *
     * @example
     * ```
     * const top = matrixBuilder.ones(2, 3);
     * const bottom = matrixBuilder.zeros(1,3);
     *
     * matrixBuilder.stack(top, bottom);
     *
     * // [ 1 1 1 ]
     * // [ 1 1 1 ]
     * // [ 0 0 0 ]
     * ```
     * @param top - The matrix that will be used for the top half of the new matrix
     * @param bottom - The matrix that will be used for the bottom half of the new matrix
     * @returns The new matrix
     * @public
     */
    MatrixBuilder.prototype.stack = function (top, bottom) {
        if (top.getNumberOfColumns() !== bottom.getNumberOfColumns()) {
            throw Error('Dimension mismatch!');
        }
        return this.fromRowVectors(__spreadArrays(top.getRowVectors(), bottom.getRowVectors()));
    };
    return MatrixBuilder;
}());
exports.MatrixBuilder = MatrixBuilder;
//# sourceMappingURL=MatrixBuilder.js.map