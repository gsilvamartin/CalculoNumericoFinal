"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../../utilities/ErrorAssertions");
/**
 * Implements {@link Matrix} with a 2-dimensional array of values.
 *
 * @remarks
 * Subclasses must specify the usual scalar operations on their contents.
 *
 * @public
 */
var ArrayMatrix = /** @class */ (function () {
    /**
     * @internal
     */
    function ArrayMatrix(data) {
        ErrorAssertions_1.assertRectangular(data);
        if (data.length !== 0 && data[0].length === 0) {
            data = [];
        }
        this._data = Object.freeze(data);
    }
    /**
     * {@inheritDoc Matrix.add}
     */
    ArrayMatrix.prototype.add = function (other) {
        ErrorAssertions_1.assertDimensionMatch(this, other);
        return this.builder().fromColumnVectors(this.getColumnVectors().map(function (column, columnIndex) { return column.add(other.getColumn(columnIndex)); }));
    };
    /**
     * {@inheritDoc Matrix.adjoint}
     */
    ArrayMatrix.prototype.adjoint = function () {
        var ops = this.ops();
        return this.transpose().map(function (e) { return ops.conjugate(e); });
    };
    /**
     * {@inheritDoc Matrix.trace}
     */
    ArrayMatrix.prototype.trace = function () {
        var ops = this.ops();
        var trace = ops.zero();
        var n = Math.min.apply(Math, this.getShape());
        for (var i = 0; i < n; i++) {
            trace = ops.add(trace, this.getEntry(i, i));
        }
        return trace;
    };
    /**
     * {@inheritDoc Matrix.apply}
     */
    ArrayMatrix.prototype.apply = function (vector) {
        var vectorAsColumnMatrix = this.builder().fromColumnVectors([vector]);
        return this.multiply(vectorAsColumnMatrix).getColumn(0);
    };
    /**
     * {@inheritDoc Matrix.equals}
     */
    ArrayMatrix.prototype.equals = function (other) {
        if (this.getNumberOfColumns() !== other.getNumberOfColumns()) {
            return false;
        }
        if (this.getNumberOfRows() !== other.getNumberOfRows()) {
            return false;
        }
        return this.getColumnVectors()
            .map(function (column, i) { return column.equals(other.getColumn(i)); })
            .reduce(function (all, current) { return all && current; }, true);
    };
    /**
     * {@inheritDoc Matrix.getColumn}
     */
    ArrayMatrix.prototype.getColumn = function (j) {
        if (j > this.getNumberOfColumns() - 1 || j < 0) {
            throw new Error('Index out of bounds');
        }
        return this.getColumnVectors()[j];
    };
    /**
     * {@inheritDoc Matrix.getColumnVectors}
     */
    ArrayMatrix.prototype.getColumnVectors = function () {
        return this.transpose().getRowVectors();
    };
    /**
     * {@inheritDoc Matrix.getDiagonal}
     */
    ArrayMatrix.prototype.getDiagonal = function () {
        var _this = this;
        var numDiagonalElements = Math.min.apply(Math, this.getShape());
        return this.vectorBuilder().fromIndexFunction(numDiagonalElements, function (i) { return _this.getEntry(i, i); });
    };
    /**
     * {@inheritDoc Matrix.toArray}
     */
    ArrayMatrix.prototype.toArray = function () {
        return this.getRowVectors().map(function (row) { return __spreadArrays(row.toArray()); });
    };
    /**
     * {@inheritdoc Matrix.getSparseData}
     */
    ArrayMatrix.prototype.getSparseData = function () {
        var ops = this.ops();
        var zero = ops.zero();
        var sparseData = new Map();
        this.forEach(function (value, rowIndex, colIndex) {
            if (ops.equals(zero, value)) {
                return;
            }
            var rowData = sparseData.get(rowIndex);
            if (rowData) {
                rowData.set(colIndex, value);
            }
            else {
                var newRowData = new Map();
                newRowData.set(colIndex, value);
                sparseData.set(rowIndex, newRowData);
            }
        });
        return sparseData;
    };
    /**
     * {@inheritDoc Matrix.getEntry}
     */
    ArrayMatrix.prototype.getEntry = function (i, j) {
        ErrorAssertions_1.assertValidMatrixIndex(this, i, j);
        return this.getRow(i).getEntry(j);
    };
    /**
     * {@inheritDoc Matrix.getShape}
     */
    ArrayMatrix.prototype.getShape = function () {
        return [this.getNumberOfRows(), this.getNumberOfColumns()];
    };
    /**
     * {@inheritDoc Matrix.getNumberOfColumns}
     */
    ArrayMatrix.prototype.getNumberOfColumns = function () {
        return (this._data[0] && this._data[0].length) || 0;
    };
    /**
     * {@inheritDoc Matrix.getNumberOfRows}
     */
    ArrayMatrix.prototype.getNumberOfRows = function () {
        return this._data.length;
    };
    /**
     * {@inheritDoc Matrix.getRow}
     */
    ArrayMatrix.prototype.getRow = function (i) {
        if (i > this.getNumberOfRows() - 1 || i < 0) {
            throw new Error('Index out of bounds');
        }
        return this.getRowVectors()[i];
    };
    /**
     * {@inheritDoc Matrix.getRowVectors}
     */
    ArrayMatrix.prototype.getRowVectors = function () {
        var _this = this;
        return this._data.map(function (dataRow) { return _this.vectorBuilder().fromArray(dataRow); });
    };
    /**
     * {@inheritDoc Matrix.multiply}
     */
    ArrayMatrix.prototype.multiply = function (other) {
        ErrorAssertions_1.assertMultiplicable(this, other);
        return this.builder().fromArray(this.getRowVectors().map(function (row) {
            return other.getColumnVectors().map(function (column) { return row.innerProduct(column); });
        }));
    };
    /**
     * {@inheritDoc Matrix.scalarMultiply}
     */
    ArrayMatrix.prototype.scalarMultiply = function (scalar) {
        return this.builder().fromColumnVectors(this.getColumnVectors().map(function (column) { return column.scalarMultiply(scalar); }));
    };
    /**
     * {@inheritDoc Matrix.set}
     */
    ArrayMatrix.prototype.set = function (i, j, value) {
        ErrorAssertions_1.assertValidMatrixIndex(this, i, j);
        var copy = this.toArray();
        copy[i][j] = value;
        return this.builder().fromArray(copy);
    };
    /**
     * {@inheritDoc Matrix.transpose}
     */
    ArrayMatrix.prototype.transpose = function () {
        return this.builder().fromColumnVectors(this.getRowVectors());
    };
    /**
     * {@inheritDoc Matrix.forEach}
     */
    ArrayMatrix.prototype.forEach = function (cb) {
        this.getRowVectors().forEach(function (row, i) {
            row.forEach(function (entry, j) {
                cb(entry, i, j);
            });
        });
    };
    /**
     * {@inheritDoc Matrix.map}
     */
    ArrayMatrix.prototype.map = function (entryFunction) {
        var newRows = this.getRowVectors().map(function (row, rowIndex) {
            return row.map(function (entry, colIndex) { return entryFunction(entry, rowIndex, colIndex); });
        });
        return this.builder().fromRowVectors(newRows);
    };
    /**
     * {@inheritDoc Matrix.combine}
     */
    ArrayMatrix.prototype.combine = function (other, combineEntries) {
        ErrorAssertions_1.assertDimensionMatch(this, other);
        return this.map(function (entry, i, j) { return combineEntries(entry, other.getEntry(i, j)); });
    };
    return ArrayMatrix;
}());
exports.ArrayMatrix = ArrayMatrix;
//# sourceMappingURL=ArrayMatrix.js.map