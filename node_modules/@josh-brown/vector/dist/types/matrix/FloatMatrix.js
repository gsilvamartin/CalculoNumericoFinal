"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var StaticImplements_1 = require("../../utilities/StaticImplements");
var NumberOperations_1 = require("../scalar/NumberOperations");
var FloatVector_1 = require("../vector/FloatVector");
var VectorBuilder_1 = require("../vector/VectorBuilder");
var MatrixBuilder_1 = require("./MatrixBuilder");
var ErrorAssertions_1 = require("../../utilities/ErrorAssertions");
/**
 * A dense matrix of JavaScript `number` primitives, implemented as a column-major `Float64Array`
 * @public
 */
var FloatMatrix = /** @class */ (function () {
    function FloatMatrix(data, shape) {
        if (data instanceof Float64Array && Array.isArray(shape)) {
            if (data.length !== shape[0] * shape[1])
                throw new Error("Dimension mismatch");
            this._data = data;
            this._shape = shape;
            return this;
        }
        data = data; // TODO: Why is this needed?
        ErrorAssertions_1.assertRectangular(data);
        var m = data.length;
        var n = m ? data[0].length : 0;
        if (!m || !n) {
            this._data = new Float64Array(0);
            this._shape = [0, 0];
            return this;
        }
        var columnMajorData = [];
        for (var j = 0; j < n; j++) {
            for (var i = 0; i < m; i++) {
                columnMajorData.push(data[i][j]);
            }
        }
        this._data = Float64Array.from(columnMajorData);
        this._shape = [m, n];
    }
    FloatMatrix_1 = FloatMatrix;
    FloatMatrix.ops = function () {
        return new NumberOperations_1.NumberOperations();
    };
    FloatMatrix.builder = function () {
        return new MatrixBuilder_1.MatrixBuilder(FloatMatrix_1);
    };
    FloatMatrix.vectorBuilder = function () {
        return new VectorBuilder_1.VectorBuilder(FloatVector_1.FloatVector);
    };
    /**
     * {@inheritDoc ArrayMatrix.ops}
     */
    FloatMatrix.prototype.ops = function () {
        return FloatMatrix_1.ops();
    };
    /**
     * {@inheritDoc ArrayMatrix.builder}
     */
    FloatMatrix.prototype.builder = function () {
        return FloatMatrix_1.builder();
    };
    /**
     * {@inheritDoc ArrayMatrix.vectorBuilder}
     */
    FloatMatrix.prototype.vectorBuilder = function () {
        return FloatMatrix_1.vectorBuilder();
    };
    /**
     * {@inheritDoc Matrix.add}
     */
    FloatMatrix.prototype.add = function (other) {
        ErrorAssertions_1.assertDimensionMatch(this, other);
        var dataCopy = new Float64Array(this._data);
        for (var i = 0; i < this._data.length; i++) {
            dataCopy[i] = this._data[i] + other.getEntry.apply(other, this.getIndices(i));
        }
        return new FloatMatrix_1(dataCopy, this._shape);
    };
    /**
     * {@inheritDoc Matrix.adjoint}
     */
    FloatMatrix.prototype.adjoint = function () {
        return this.transpose(); // This implementation is real-valued
    };
    /**
     * {@inheritDoc Matrix.trace}
     */
    FloatMatrix.prototype.trace = function () {
        var ops = this.ops();
        var trace = ops.zero();
        var n = Math.min(this.getNumberOfColumns(), this.getNumberOfRows());
        for (var i = 0; i < n; i++) {
            trace = ops.add(trace, this.getEntry(i, i));
        }
        return trace;
    };
    /**
     * {@inheritDoc Matrix.apply}
     */
    FloatMatrix.prototype.apply = function (vector) {
        var colShape = [vector.getDimension(), 1];
        var vectorAsColumnMatrix = new FloatMatrix_1(Float64Array.from(vector.toArray()), colShape);
        return this.multiply(vectorAsColumnMatrix).getColumn(0);
    };
    /**
     * {@inheritDoc Matrix.equals}
     */
    FloatMatrix.prototype.equals = function (other) {
        var _a = this._shape, m = _a[0], n = _a[1];
        if (n !== other.getNumberOfColumns()) {
            return false;
        }
        if (m !== other.getNumberOfRows()) {
            return false;
        }
        var ops = this.ops();
        for (var j = 0; j < n; j++) {
            for (var i = 0; i < m; i++) {
                if (!ops.equals(this.getEntry(i, j), other.getEntry(i, j))) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * {@inheritDoc Matrix.getColumn}
     */
    FloatMatrix.prototype.getColumn = function (j) {
        var columnData = new Float64Array(this.getNumberOfRows());
        for (var i = 0; i < this.getNumberOfRows(); i++) {
            columnData[i] = this.getEntry(i, j);
        }
        return new FloatVector_1.FloatVector(columnData);
    };
    /**
     * {@inheritDoc Matrix.getColumnVectors}
     */
    FloatMatrix.prototype.getColumnVectors = function () {
        var _a = this._shape, m = _a[0], n = _a[1];
        var columnArrays = [];
        // Initialize the row arrays
        for (var j = 0; j < n; j++) {
            columnArrays.push(new Float64Array(m));
        }
        // Fill in the data
        for (var index = 0; index < this._data.length; index++) {
            var _b = this.getIndices(index), i = _b[0], j = _b[1];
            columnArrays[j][i] = this._data[index];
        }
        return columnArrays.map(function (columnData) { return new FloatVector_1.FloatVector(columnData); });
    };
    /**
     * {@inheritDoc Matrix.getDiagonal}
     */
    FloatMatrix.prototype.getDiagonal = function () {
        var numDiagonalElements = Math.min(this.getNumberOfRows(), this.getNumberOfColumns());
        var vectorData = new Float64Array(numDiagonalElements);
        for (var i = 0; i < numDiagonalElements; i++) {
            vectorData[i] = this.getEntry(i, i);
        }
        return new FloatVector_1.FloatVector(vectorData);
    };
    /**
     * {@inheritDoc Matrix.toArray}
     */
    FloatMatrix.prototype.toArray = function () {
        var arr = [];
        // Initialize the arrays
        for (var i = 0; i < this.getNumberOfRows(); i++) {
            arr[i] = new Array(this.getNumberOfColumns());
        }
        // Fill in the data
        for (var index = 0; index < this._data.length; index++) {
            var _a = this.getIndices(index), i = _a[0], j = _a[1];
            arr[i][j] = this._data[index];
        }
        return arr;
    };
    /**
     * {@inheritdoc Matrix.getSparseData}
     */
    FloatMatrix.prototype.getSparseData = function () {
        var ops = this.ops();
        var zero = ops.zero();
        var sparseData = new Map();
        this.forEach(function (value, rowIndex, colIndex) {
            if (ops.equals(zero, value)) {
                return;
            }
            var rowData = sparseData.get(rowIndex);
            if (rowData) {
                rowData.set(colIndex, value);
            }
            else {
                var newRowData = new Map();
                newRowData.set(colIndex, value);
                sparseData.set(rowIndex, newRowData);
            }
        });
        return sparseData;
    };
    /**
     * {@inheritDoc Matrix.getEntry}
     */
    FloatMatrix.prototype.getEntry = function (i, j) {
        ErrorAssertions_1.assertValidMatrixIndex(this, i, j);
        return this._data[this.getArrayIndex(i, j)];
    };
    /**
     * {@inheritDoc Matrix.getShape}
     */
    FloatMatrix.prototype.getShape = function () {
        return __spreadArrays(this._shape);
    };
    /**
     * {@inheritDoc Matrix.getNumberOfColumns}
     */
    FloatMatrix.prototype.getNumberOfColumns = function () {
        return this._shape[1];
    };
    /**
     * {@inheritDoc Matrix.getNumberOfRows}
     */
    FloatMatrix.prototype.getNumberOfRows = function () {
        return this._shape[0];
    };
    /**
     * {@inheritDoc Matrix.getRow}
     */
    FloatMatrix.prototype.getRow = function (i) {
        var rowData = new Float64Array(this.getNumberOfColumns());
        for (var j = 0; j < this.getNumberOfColumns(); j++) {
            rowData[j] = this.getEntry(i, j);
        }
        return new FloatVector_1.FloatVector(rowData);
    };
    /**
     * {@inheritDoc Matrix.getRowVectors}
     */
    FloatMatrix.prototype.getRowVectors = function () {
        var _a = this._shape, m = _a[0], n = _a[1];
        var rowArrays = [];
        // Initialize the row arrays
        for (var i = 0; i < m; i++) {
            rowArrays.push(new Float64Array(n));
        }
        // Fill in the data
        for (var index = 0; index < this._data.length; index++) {
            var _b = this.getIndices(index), i = _b[0], j = _b[1];
            rowArrays[i][j] = this._data[index];
        }
        return rowArrays.map(function (rowData) { return new FloatVector_1.FloatVector(rowData); });
    };
    /**
     * {@inheritDoc Matrix.multiply}
     */
    FloatMatrix.prototype.multiply = function (other) {
        ErrorAssertions_1.assertMultiplicable(this, other);
        var thisRows = this.getRowVectors();
        var otherColumns = other.getColumnVectors();
        var newData = new Float64Array(this.getNumberOfRows() * other.getNumberOfColumns());
        for (var j = 0; j < other.getNumberOfColumns(); j++) {
            for (var i = 0; i < this.getNumberOfRows(); i++) {
                newData[j * this.getNumberOfRows() + i] = thisRows[i].innerProduct(otherColumns[j]);
            }
        }
        return new FloatMatrix_1(newData, [this.getNumberOfRows(), other.getNumberOfColumns()]);
    };
    /**
     * {@inheritDoc Matrix.scalarMultiply}
     */
    FloatMatrix.prototype.scalarMultiply = function (scalar) {
        var newData = new Float64Array(this._data).map(function (entry) { return entry * scalar; });
        return new FloatMatrix_1(newData, this._shape);
    };
    /**
     * {@inheritDoc Matrix.set}
     */
    FloatMatrix.prototype.set = function (i, j, value) {
        ErrorAssertions_1.assertValidMatrixIndex(this, i, j);
        var dataCopy = new Float64Array(this._data);
        dataCopy[this.getArrayIndex(i, j)] = value;
        return new FloatMatrix_1(dataCopy, this._shape);
    };
    /**
     * {@inheritDoc Matrix.transpose}
     */
    FloatMatrix.prototype.transpose = function () {
        // TODO - if we also had a row-major implementation then this operation could be free.
        var _a = this._shape, m = _a[0], n = _a[1];
        var copy = new Float64Array(this._data.length);
        for (var index = 0; index < this._data.length; index++) {
            var _b = this.getIndices(index), i = _b[0], j = _b[1];
            copy[i * n + j] = this.getEntry(i, j);
        }
        return new FloatMatrix_1(copy, [n, m]);
    };
    /**
     * {@inheritDoc Matrix.forEach}
     */
    FloatMatrix.prototype.forEach = function (cb) {
        var _this = this;
        this._data.forEach(function (value, index) {
            var _a = _this.getIndices(index), i = _a[0], j = _a[1];
            cb(value, i, j);
        });
    };
    /**
     * {@inheritDoc Matrix.map}
     */
    FloatMatrix.prototype.map = function (entryFunction) {
        var _this = this;
        var newData = this._data.map(function (value, arrIndex) {
            var _a = _this.getIndices(arrIndex), i = _a[0], j = _a[1];
            return entryFunction(value, i, j);
        });
        return new FloatMatrix_1(newData, this.getShape());
    };
    /**
     * {@inheritDoc Matrix.combine}
     */
    FloatMatrix.prototype.combine = function (other, combineEntries) {
        ErrorAssertions_1.assertDimensionMatch(this, other);
        return this.map(function (entry, i, j) { return combineEntries(entry, other.getEntry(i, j)); });
    };
    FloatMatrix.prototype.getArrayIndex = function (i, j) {
        var m = this._shape[0];
        return j * m + i;
    };
    FloatMatrix.prototype.getIndices = function (arrayIndex) {
        var m = this._shape[0];
        var i = arrayIndex % m;
        var j = Math.floor(arrayIndex / m);
        return [i, j];
    };
    var FloatMatrix_1;
    FloatMatrix = FloatMatrix_1 = __decorate([
        StaticImplements_1.StaticImplements(),
        __metadata("design:paramtypes", [Object, Array])
    ], FloatMatrix);
    return FloatMatrix;
}());
exports.FloatMatrix = FloatMatrix;
//# sourceMappingURL=FloatMatrix.js.map