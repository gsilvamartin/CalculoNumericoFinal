"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatrixProperties_1 = require("../utilities/MatrixProperties");
var GaussJordan_1 = require("../operations/GaussJordan");
var LinearSolution_1 = require("../solvers/LinearSolution");
var QRDecomposition_1 = require("../decompositions/QRDecomposition");
// TODO - convert to an upper Hessenberg matrix to improve rate of convergence
var defaultIterations = 100;
/**
 * Uses the QR algorithm to compute the eigenvalues and eigenvectors of a matrix `A`
 *
 * @param A - The matrix for which to compute eigenvalues
 * @param numIterations - The number of iterations to take
 * @returns An array of eigenvalue-eigenvalue pairs
 * @public
 */
function eig(A, numIterations) {
    if (numIterations === void 0) { numIterations = defaultIterations; }
    var eigenvalues = calculateEigenvalues(A, numIterations);
    return eigenvalues.toArray().map(function (eigenvalue) {
        var eigenvector = getEigenvectorForEigenvalue(A, eigenvalue);
        return { eigenvalue: eigenvalue, eigenvector: eigenvector };
    });
}
exports.eig = eig;
/**
 * Uses the QR algorithm to compute the eigenvalues of a matrix `A`
 *
 * @param A - The matrix for which to compute eigenvalues
 * @param numIterations - The number of iterations to take
 * @public
 */
function calculateEigenvalues(A, numIterations) {
    if (numIterations === void 0) { numIterations = defaultIterations; }
    if (!MatrixProperties_1.isSquare(A))
        throw Error('Eigenvalues are only defined for square matrices');
    var ops = A.ops();
    var m = A.getNumberOfRows();
    if (m === 1)
        return A.getColumnVectors()[0];
    if (m === 2)
        return getTwoByTwoEigenvalues(A);
    var n = 0;
    var nthA = A;
    while (n < numIterations) {
        var _a = QRDecomposition_1.calculateQRDecomposition(nthA), Q = _a.Q, R = _a.R;
        n++;
        nthA = R.multiply(Q);
        // TODO - this early return causes us to have worse accuracy than we otherwise
        // would.  If we want to be able to return early, we need to be able to pass
        // equality tolerances around.
        // if (isUpperTriangular(nthA)) {
        //   return nthA.getDiagonal();
        // }
    }
    var eigenvalues = [];
    for (var i = 0; i < m; i++) {
        var diagonalEntry = nthA.getEntry(i, i);
        if (i === m - 1) {
            eigenvalues.push(diagonalEntry);
            continue;
        }
        var subdiagonalEntry = nthA.getEntry(i + 1, i);
        if (ops.equals(ops.zero(), subdiagonalEntry)) {
            eigenvalues.push(diagonalEntry);
            continue;
        }
        // If we're here, then either we failed to converge, or we
        // are looking at a pair of complex eigenvalues
        var subMatrix = A.builder().slice(nthA, i, i, i + 2, i + 2);
        var subEigenvalues = getTwoByTwoEigenvalues(subMatrix);
        eigenvalues.push(subEigenvalues.getEntry(0));
        eigenvalues.push(subEigenvalues.getEntry(1));
        i++; // We covered two eigenvalues, so jump ahead
    }
    return A.vectorBuilder().fromArray(eigenvalues);
}
exports.calculateEigenvalues = calculateEigenvalues;
function getTwoByTwoEigenvalues(A) {
    var ops = A.ops();
    var data = A.toArray();
    var _a = data[0], a00 = _a[0], a01 = _a[1];
    var _b = data[1], a10 = _b[0], a11 = _b[1];
    // b, and c are the parameters of the quadratic formula.  a is one.
    var negativeB = ops.add(a00, a11);
    var c = ops.subtract(ops.multiply(a00, a11), ops.multiply(a10, a01));
    var overTwoA = ops.fromNumber(1 / 2);
    var fourAC = ops.multiply(c, ops.fromNumber(4));
    var bSquaredMinusFourAC = ops.subtract(ops.multiply(negativeB, negativeB), fourAC);
    var rootPart = ops.getPrincipalSquareRoot(bSquaredMinusFourAC);
    if (rootPart === undefined)
        throw Error('This scalar type does not support complex values');
    var firstEigenvalue = ops.multiply(ops.add(negativeB, rootPart), overTwoA);
    var secondEigenvalue = ops.multiply(ops.subtract(negativeB, rootPart), overTwoA);
    return A.vectorBuilder().fromValues(firstEigenvalue, secondEigenvalue);
}
/**
 * Given a matrix `A` and an eigenvalue `lambda` of that matrix, returns the
 * eigenvector of `A` corresponding to `lambda`
 *
 * @param A - The matrix with eigenvalue `lambda`
 * @param lambda - The eigenvalue for which to find an eigenvector
 * @public
 */
function getEigenvectorForEigenvalue(A, lambda) {
    var builder = A.builder();
    var vectorBuilder = A.vectorBuilder();
    var ops = A.ops();
    var m = A.getNumberOfRows();
    var minusLambda = ops.multiply(lambda, ops.negativeOne());
    var minusLambdaI = builder.identity(A.getNumberOfColumns()).scalarMultiply(minusLambda);
    var aMinusLambdaI = A.add(minusLambdaI);
    var zero = vectorBuilder.zeros(m);
    var eigenvectorSolution = GaussJordan_1.solveByGaussianElimination(aMinusLambdaI, zero);
    if (eigenvectorSolution.solutionType === LinearSolution_1.SolutionType.OVERDETERMINED) {
        // Should never happen, since 0 is always a solution
        throw new Error("Unexpected error: unable to find a solution to the eigenvector equation");
    }
    // If zero is the only solution to the eigenvector equation,
    // then lambda was not an eigenvalue to begin with.
    if (eigenvectorSolution.solutionType === LinearSolution_1.SolutionType.UNIQUE &&
        eigenvectorSolution.solution.equals(zero)) {
        throw new Error("Cannot find an eigenvector; " + lambda + " is not an eigenvalue of the provided matrix");
    }
    return eigenvectorSolution.solution;
}
exports.getEigenvectorForEigenvalue = getEigenvectorForEigenvalue;
//# sourceMappingURL=Eigenvalues.js.map