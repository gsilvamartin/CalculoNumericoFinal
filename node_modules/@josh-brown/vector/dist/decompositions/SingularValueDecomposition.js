"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Norms_1 = require("../operations/Norms");
var GaussJordan_1 = require("../operations/GaussJordan");
/**
 * Uses the Power Method to calculate the Singular Value Decomposition of a matrix `A`
 *
 * @remarks
 * A Singular Value Decomposition consists of orthogonal matrices `U` and `V`
 * and a diagonal matrix `Sigma` such that _USigmaV* = A_
 *
 * @param A - the matrix to decompose
 * @public
 */
function calculateSingularValueDecomposition(A) {
    var ops = A.ops();
    var builder = A.builder();
    var vectorBuilder = A.vectorBuilder();
    var r = GaussJordan_1.rank(A);
    var uColumns = [];
    var vColumns = [];
    var singularValues = [];
    for (var i = 0; i < r; i++) {
        var _a = getFirstSingularValue(A), u = _a.u, sigma = _a.sigma, v = _a.v;
        uColumns.push(u);
        singularValues.push(sigma);
        vColumns.push(v);
        var delta = u
            .outerProduct(v)
            .scalarMultiply(sigma)
            .scalarMultiply(ops.negativeOne());
        A = A.add(delta);
    }
    var U = builder.fromColumnVectors(uColumns);
    var Sigma = builder.diagonal(vectorBuilder.fromArray(singularValues));
    var V = builder.fromColumnVectors(vColumns);
    return { U: U, Sigma: Sigma, V: V };
}
exports.calculateSingularValueDecomposition = calculateSingularValueDecomposition;
function getFirstSingularValue(A) {
    var ops = A.ops();
    var vectorBuilder = A.vectorBuilder();
    var x0 = vectorBuilder.ones(A.getNumberOfColumns());
    var x = applyBToTheK(A, x0, 15); // TODO - what should k be?
    var v = Norms_1.normalize(x);
    if (v === undefined)
        throw new Error('Unexpectedly encountered 0-vector');
    var Av = A.apply(v);
    var sigma = ops.fromNumber(Norms_1.euclideanNorm(Av));
    var sigmaInverse = ops.getMultiplicativeInverse(sigma);
    if (sigmaInverse === undefined)
        throw new Error('Unexpectedly encountered singular value of 0');
    var u = Av.scalarMultiply(sigmaInverse);
    return { u: u, sigma: sigma, v: v };
}
function applyBToTheK(A, x0, k) {
    var At = A.adjoint();
    var x = x0;
    for (var i = 0; i < k; i++) {
        x = A.apply(x);
        x = At.apply(x);
    }
    return x;
}
//# sourceMappingURL=SingularValueDecomposition.js.map