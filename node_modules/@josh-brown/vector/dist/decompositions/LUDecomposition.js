"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../utilities/ErrorAssertions");
var RowOperations_1 = require("../operations/RowOperations");
/**
 * Uses the Doolittle algorithm to calculate the LU Decomposition of a matrix A.
 *
 * @remarks
 * An LU Decomposition of a matrix A is a lower-triangular matrix L, an upper-triangular
 * matrix U, and a row permutation matrix P such that _PA = LU_
 *
 * @param A - The matrix to decompose
 * @public
 */
function calculateLUDecomposition(A) {
    ErrorAssertions_1.assertSquare(A);
    var ops = A.ops();
    var N = A.getNumberOfColumns();
    var sortingResult = RowOperations_1.RowOperations.pivot(A);
    var P = sortingResult.operator;
    A = sortingResult.result;
    // U will eventually be the last U_n
    var U = A;
    // L will eventually be derived from the entries of these matrices
    var lns = [];
    for (var n = 0; n < N; n++) {
        var nthIteration = getNextDoolittleIteration(n, U);
        lns.push(nthIteration.ln);
        U = nthIteration.un;
    }
    // L will be the product of all L_n inverses.
    // For the particular form of L_n, we can take the shortcut of keeping everything
    // above the diagonal and using the negative of the entries below the diagonal.
    // This saves us from performing lots of inverses and multiplications.
    var L = A.builder().fromIndexFunction(A.getShape(), function (i, j) {
        if (i === j) {
            return ops.one();
        }
        else if (i < j) {
            return ops.zero();
        }
        else {
            return ops.multiply(lns[j].getEntry(i, j), ops.negativeOne());
        }
    });
    return { L: L, U: U, P: P };
}
exports.calculateLUDecomposition = calculateLUDecomposition;
/**
 * Given the current approximation of the upper-triangular matrix U, return
 * the next approximation (`un`) and the matrix by which we multiplied to
 * arrive at this new approximation (`ln`)
 *
 * @param columnIndex - The index of the column from which we are trying
 *     to eliminate sub-diagonal entries
 * @param previousU - The matrix from which we are trying to eliminate entries
 */
function getNextDoolittleIteration(columnIndex, previousU) {
    var ln = getNthLowerTriangularMatrix(columnIndex, previousU);
    var un = ln.multiply(previousU);
    return { ln: ln, un: un };
}
/**
 * Produces a matrix that, when multiplied by the previous U matrix
 * (which is not yet upper-triangular), will eliminate the entries
 * below the diagonal for the specified column index
 *
 * @param columnIndex - The index of the column from which we are trying
 *     to eliminate sub-diagonal entries
 * @param previousU - The matrix from which we are trying to eliminate entries
 */
function getNthLowerTriangularMatrix(columnIndex, previousU) {
    var ops = previousU.ops();
    return previousU.builder().fromIndexFunction(previousU.getShape(), function (i, j) {
        if (i === j) {
            return ops.one();
        }
        else if (i > j && j === columnIndex) {
            var numerator = previousU.getEntry(i, columnIndex);
            var denominator = previousU.getEntry(columnIndex, columnIndex);
            var quotient = ops.divide(numerator, denominator);
            if (quotient === undefined) {
                throw Error('Unexpected division by 0');
            }
            return ops.multiply(quotient, ops.negativeOne());
        }
        else {
            return ops.zero();
        }
    });
}
//# sourceMappingURL=LUDecomposition.js.map