"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatrixProperties_1 = require("../utilities/MatrixProperties");
/**
 * Uses the serial version of the Cholesky algorith to calculate the Cholesky
 * decomposition of a matrix `A`.
 *
 * @remarks
 * A Cholesky decomposition of a matrix `A` consists of a lower-triangular
 * matrix `L` such that _LL* = A_.
 *
 * A Cholesky decomposition only exists if `A` is symmetric and positive-definite.
 * @param A - The matrix to decompose
 * @public
 */
function calculateCholeskyDecomposition(A) {
    if (!MatrixProperties_1.isHermitian(A))
        return undefined;
    var ops = A.ops();
    var builder = A.builder();
    var dim = A.getNumberOfColumns();
    var L = builder.zeros([dim, dim]);
    for (var j = 0; j < dim; j++) {
        var Ajj = A.getEntry(j, j);
        var entrySquared = Ajj;
        for (var p = 0; p < j; p++) {
            var Ljp = L.getEntry(j, p);
            entrySquared = ops.subtract(entrySquared, ops.multiply(Ljp, ops.conjugate(Ljp)));
        }
        var Ljj = ops.getPrincipalSquareRoot(entrySquared);
        if (Ljj === undefined)
            return undefined;
        L = L.set(j, j, Ljj);
        for (var i = j + 1; i < dim; i++) {
            var difference = A.getEntry(i, j);
            for (var p = 0; p < j; p++) {
                var Lip = L.getEntry(i, p);
                var Ljp = L.getEntry(j, p);
                difference = ops.subtract(difference, ops.multiply(Lip, ops.conjugate(Ljp)));
            }
            var Lij = ops.divide(difference, Ljj);
            if (Lij === undefined)
                return undefined;
            L = L.set(i, j, Lij);
        }
    }
    return { L: L };
}
exports.calculateCholeskyDecomposition = calculateCholeskyDecomposition;
//# sourceMappingURL=CholeskyDecomposition.js.map