"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorAssertions_1 = require("../utilities/ErrorAssertions");
var Norms_1 = require("../operations/Norms");
/**
 * Uses the Graham-Schmidt process to calculate the QR decomposition of the matrix A.
 *
 * @remarks
 * A QR Decomposition of a matrix A is a unitary matrix Q and upper-triangular
 * matrix R such that Q multiplied by R yields A
 *
 * @param A - The matrix to decompose
 * @public
 */
function calculateQRDecomposition(A) {
    ErrorAssertions_1.assertSquare(A);
    var matrixBuilder = A.builder();
    var vectorBuilder = A.vectorBuilder();
    var ops = A.ops();
    var dim = A.getNumberOfColumns();
    // Construct a matrix U, whose columns form an orthogonal basis
    // for the column space of A, by subtracting the non-orthogonal
    // components for each column of A
    var uColumns = [];
    for (var k = 0; k < dim; k++) {
        var columnK = A.getColumn(k);
        var nonOrthogonalPart = vectorBuilder.zeros(dim);
        for (var j = 0; j < k; j++) {
            // Add the part of Ak that is not orthogonal to the already-calculated jth column of U
            nonOrthogonalPart = nonOrthogonalPart.add(columnK.projectOnto(uColumns[j]));
        }
        uColumns.push(columnK.add(nonOrthogonalPart.scalarMultiply(ops.negativeOne())));
    }
    // The unitary matrix Q is just U with all of its columns normalized.
    // These columns are, then, an orthonormal basis for the column space of A.
    // If any columns are the zero vector, then A was not full-rank to begin with.
    var qColumns = [];
    for (var i = 0; i < dim; i++) {
        var qi = Norms_1.normalize(uColumns[i]);
        if (qi === undefined) {
            throw Error('A is singular; no QR decomposition exists');
        }
        qColumns.push(qi);
    }
    var Q = matrixBuilder.fromColumnVectors(qColumns);
    // The upper-triangular matrix R is formed by computing inner
    // products of our new basis vectors with the columns of A.
    var R = matrixBuilder.fromIndexFunction([dim, dim], function (i, j) {
        if (i > j) {
            return ops.zero();
        }
        return A.getColumn(j).innerProduct(Q.getColumn(i));
    });
    return { Q: Q, R: R };
}
exports.calculateQRDecomposition = calculateQRDecomposition;
//# sourceMappingURL=QRDecomposition.js.map