"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function approximatelyEqual(first, second, epsilon) {
    if (epsilon === void 0) { epsilon = 0.000001; }
    if (Number.isNaN(first) || Number.isNaN(second)) {
        return false; // NaN should never equal itself
    }
    if (!Number.isFinite(first) || !Number.isFinite(second)) {
        return false; // Infinities do not equal themselves
    }
    return Math.abs(first - second) < epsilon;
}
exports.approximatelyEqual = approximatelyEqual;
function mod(num, modulus) {
    // Operator % yields negative results for negative numbers.
    return ((num % modulus) + modulus) % modulus;
}
exports.mod = mod;
function random(min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 1; }
    return min + Math.random() * (max - min);
}
exports.random = random;
function randomNormal(mean, standardDeviation, numberOfSamples) {
    if (mean === void 0) { mean = 0; }
    if (standardDeviation === void 0) { standardDeviation = 1; }
    if (numberOfSamples === void 0) { numberOfSamples = 10; }
    var total = 0;
    for (var i = 0; i < numberOfSamples; i++) {
        total += random();
    }
    var halfNumberOfSamples = numberOfSamples / 2;
    return mean + (standardDeviation * (total - halfNumberOfSamples)) / halfNumberOfSamples;
}
exports.randomNormal = randomNormal;
// memoize these results
var binomialResults = new Map();
var factorialResults = new Map();
factorialResults.set(0, 1);
function binomial(n, k) {
    if (!binomialResults.has(n)) {
        binomialResults.set(n, new Map());
    }
    var mapForA = binomialResults.get(n);
    if (!mapForA.has(k)) {
        if (k > n) {
            mapForA.set(k, 0);
        }
        else {
            var numerator = factorial(n);
            var denominator = factorial(n - k) * factorial(k);
            var result = numerator / denominator;
            mapForA.set(k, result);
        }
    }
    return mapForA.get(k);
}
exports.binomial = binomial;
function factorial(n) {
    if (!factorialResults.has(n)) {
        var result = n * factorial(n - 1);
        factorialResults.set(n, result);
    }
    return factorialResults.get(n);
}
exports.factorial = factorial;
function sigmoid(x) {
    var ex = Math.exp(x);
    return ex / (1 + ex);
}
exports.sigmoid = sigmoid;
//# sourceMappingURL=NumberUtilities.js.map